[{"content":"https://leetcode.com/problems/find-the-town-judge/\ngraphの問題で、trust のペア, [a, b] は a から b に向かう directed edge である。\n例えば、 N = 5 で trust trust = [[1,3],[2,3],[4,3],[4,1],[5,3],[5,1],[5,4]] の場合下記のような graph になる。\n3 は 1,2,4,5 から信頼されていて、 誰も信頼していない。 そのため、judge は 3 になる。\nこの graph theory の、 outdegree の辺は、 その人が他の人を信頼している数になる。\nindegree の辺は他の人から信頼されている数になる。\nそのため indegree と outdegree によって誰が judge か判断できる。\njudge は outdegree が 0 で indegree が N - 1 となる。\ntrust をループして全員の indegree, outdegree の数を調査できる。\nindegree = [0] * (N + 1) outdegree = [0] * (N + 1) for a, b in trust: outdegree[a] += 1 indegree[b] += 1 そして、1 ～ N 人全員をループして、チェックすれば、 judge がわかる。\nfor i in range(1, N + 1): if indegree[i] == N - 1 and outdegree[i] == 0: return i return -1 Time complexity: O(E)\nMem complexity: O(n)\ndef findJudge(self, N: int, trust: List[List[int]]) -\u0026gt; int: if len(trust) \u0026lt; N - 1: return -1 indegree = [0] * (N + 1) outdegree = [0] * (N + 1) for a, b in trust: outdegree[a] += 1 indegree[b] += 1 for i in range(1, N + 1): if indegree[i] == N - 1 and outdegree[i] == 0: return i return -1 ","permalink":"https://hirotoshimizu.github.io/posts/find-the-town-judge/","summary":"https://leetcode.com/problems/find-the-town-judge/\ngraphの問題で、trust のペア, [a, b] は a から b に向かう directed edge である。\n例えば、 N = 5 で trust trust = [[1,3],[2,3],[4,3],[4,1],[5,3],[5,1],[5,4]] の場合下記のような graph になる。\n3 は 1,2,4,5 から信頼されていて、 誰も信頼していない。 そのため、judge は 3 になる。\nこの graph theory の、 outdegree の辺は、 その人が他の人を信頼している数になる。\nindegree の辺は他の人から信頼されている数になる。\nそのため indegree と outdegree によって誰が judge か判断できる。\njudge は outdegree が 0 で indegree が N - 1 となる。\ntrust をループして全員の indegree, outdegree の数を調査できる。\nindegree = [0] * (N + 1) outdegree = [0] * (N + 1) for a, b in trust: outdegree[a] += 1 indegree[b] += 1 そして、1 ～ N 人全員をループして、チェックすれば、 judge がわかる。","title":"Find the Town Judge"},{"content":"DFS\nBase Case root が Null は None を返す。\nTree を反転して値が同じなら True を返すので、\nchildren node の値を swap して同じか確かめる。\nTime complexity: O(n)\nMem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def invertTree(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; if not root: return None tmp = root.left root.left = root.right root.right = tmp self.invertTree(root.left) self.invertTree(root.right) return root ","permalink":"https://hirotoshimizu.github.io/posts/invert-binary-tree/","summary":"DFS\nBase Case root が Null は None を返す。\nTree を反転して値が同じなら True を返すので、\nchildren node の値を swap して同じか確かめる。\nTime complexity: O(n)\nMem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def invertTree(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; if not root: return None tmp = root.","title":"Invert Binary Tree"},{"content":"DFS recursive\nBase Case は p,q が Null の場合同じ Tree なので return する。\nもし p,q のどちらかの値が違う場合、その Tree は同じではないので、 False を return する。 また、どちらかの値が Null の場合同じ Tree ではないので、この場合も False を　return する。\nTime complexity: O(n) Mem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSameTree(self, p, q): \u0026#34;\u0026#34;\u0026#34; :type p: TreeNode :type q: TreeNode :rtype: bool \u0026#34;\u0026#34;\u0026#34; if not p and not q: return True if not p or not q or p.val != q.val: return False return(self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)) ","permalink":"https://hirotoshimizu.github.io/posts/same-tree/","summary":"DFS recursive\nBase Case は p,q が Null の場合同じ Tree なので return する。\nもし p,q のどちらかの値が違う場合、その Tree は同じではないので、 False を return する。 また、どちらかの値が Null の場合同じ Tree ではないので、この場合も False を　return する。\nTime complexity: O(n) Mem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSameTree(self, p, q): \u0026#34;\u0026#34;\u0026#34; :type p: TreeNode :type q: TreeNode :rtype: bool \u0026#34;\u0026#34;\u0026#34; if not p and not q: return True if not p or not q or p.","title":"Same Tree"},{"content":"回答のアプローチは Recursive DFS BFS Iterative DFS\nBase case root が empty children が Null\nRecursive DFS\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def maxDepth(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: int \u0026#34;\u0026#34;\u0026#34; if not root: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) BFS\nBFS を使う場合は Queue を使う。\n 3  ／　＼ 9 20 ／＼ 15 7\n | 3 | 9 | 20 | 15 | 7 | 1 2 2 3 3 ← Level\n | 3 | 1\nQueue を deque していくと 最終的に Queue の値がなくなるので、 その時に level を返す。\nif not root: retunr 0 level = 0 q = deque([root]) while q: for i in range(len(q)): node = q.popleft() if node.left: q.append(node.left) if node.right: q.append(node.right) level += 1 return level Iterative DFS\nPre-order DFS\nstack\n | node depth | | 3 1 | pop して\n | node depth | | 20 2 | | 9 2 | pop して\n | node depth | | 20 2 | 20 には子がいるので、stack に追加\n | node depth | | 7 3 | | 15 3 | stack = [[root, 1]] res = 0 while stack: node, depth = stack.pop() if node: res = max(res, depth) stack.append([node.left, depth + 1]) stack.append([node.right, depth + 1]) return res ","permalink":"https://hirotoshimizu.github.io/posts/maximum-depth-of-binary-tree/","summary":"回答のアプローチは Recursive DFS BFS Iterative DFS\nBase case root が empty children が Null\nRecursive DFS\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def maxDepth(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: int \u0026#34;\u0026#34;\u0026#34; if not root: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) BFS\nBFS を使う場合は Queue を使う。\n 3  ／　＼ 9 20 ／＼ 15 7\n | 3 | 9 | 20 | 15 | 7 | 1 2 2 3 3 ← Level","title":"Maximum Depth of Binary Tree"},{"content":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\nこの問題の回答方法としては Recursive と Iterative なアプローチがある。\nRecursive Approach\nアルゴリズム\n ルートの Node から始める。 p と q が右の subtree にある場合、1から右のsubtreeを探すようにする。 p と q が左の subtree にある場合、1から左のsubtreeを探すようにする。 もし 2 と 3 のステップが not true の場合、p と q の共通の Node を見つけたこととなる。  Time complexity: O(n)\nMem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def lowestCommonAncestor(self, root, p, q): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; parent_val = root.val p_val = p.val q_val = q.val if p_val \u0026gt; parent_val and q_val \u0026gt; parent_val: return self.lowestCommonAncestor(root.right, p, q) elif p_val \u0026lt; parent_val and q_val \u0026lt; parent_val: return self.lowestCommonAncestor(root.left, p, q) else: return root Iterative Approach\nアルゴリズム\nやり方としては Recursive なアプローチと似ている。 違いとしては、recursive な function を呼ぶ代わりに、tree を 横断する。\nそのため、backtrace して、LCA node を探す必要がないため stack,recursion を使わない。 Iterative なやり方としては、分かれるポイントを探すこと。\nTime complexity: O(n)\nMem complexity: O(1)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def lowestCommonAncestor(self, root, p, q): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; cur = root while cur: if p.val \u0026gt; cur.val and q.val \u0026gt; cur.val: cur = cur.right elif p.val \u0026lt; cur.val and q.val \u0026lt; cur.val: cur = cur.left else: return cur ","permalink":"https://hirotoshimizu.github.io/posts/lowest-common-ancestor-of-a-binary-search-tree/","summary":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\nこの問題の回答方法としては Recursive と Iterative なアプローチがある。\nRecursive Approach\nアルゴリズム\n ルートの Node から始める。 p と q が右の subtree にある場合、1から右のsubtreeを探すようにする。 p と q が左の subtree にある場合、1から左のsubtreeを探すようにする。 もし 2 と 3 のステップが not true の場合、p と q の共通の Node を見つけたこととなる。  Time complexity: O(n)\nMem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def lowestCommonAncestor(self, root, p, q): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; parent_val = root.","title":"Lowest Common Ancestor of a Binary Search Tree"},{"content":"https://leetcode.com/problems/climbing-stairs/\nn = 5\n 0 ／　＼ 1 2 ／＼ ／＼ 2 3 3 4 ／＼ ／＼ ／＼ ／＼ 3 4 4 5 4 5 5 6  ／＼ ／＼ ／＼　／＼ 4 5 5 6 5 6　5 6 ／＼ 5 6\nn が 5 steps の場合、 8通りの選択が出来る。\nDFS でも出来るかが 2^n となる。\nそのため Dynamic Programming を使う。\n同じ計算をする値は memoize する\n | 8 | 5 | 3 | 2 | 1 | 1 | n に辿り着くまでの数 0 1 2 3 4 5(step) one two\nn に辿り着くまでの数はBase Number を基に計算できる。\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def climbStairs(self, n): \u0026#34;\u0026#34;\u0026#34; :type n: int :rtype: int \u0026#34;\u0026#34;\u0026#34; one, two = 1, 1 for i in n: temp = one one = one + two two = temp return one ","permalink":"https://hirotoshimizu.github.io/posts/climbing-stairs/","summary":"https://leetcode.com/problems/climbing-stairs/\nn = 5\n 0 ／　＼ 1 2 ／＼ ／＼ 2 3 3 4 ／＼ ／＼ ／＼ ／＼ 3 4 4 5 4 5 5 6  ／＼ ／＼ ／＼　／＼ 4 5 5 6 5 6　5 6 ／＼ 5 6\nn が 5 steps の場合、 8通りの選択が出来る。\nDFS でも出来るかが 2^n となる。\nそのため Dynamic Programming を使う。\n同じ計算をする値は memoize する\n | 8 | 5 | 3 | 2 | 1 | 1 | n に辿り着くまでの数 0 1 2 3 4 5(step) one two","title":"Climbing Stairs"},{"content":"https://leetcode.com/problems/meeting-rooms/\n先ず始めに intervals のスタート時間でソートする。\nintervals の時間がソートされたため、 ループで最初の会議の終わりの時間と次の会議の始まりの時間を比較し、 最初の会議の終わりの時間 が 次の会議の始まりの時間より大きい場合、 会議の時間が重なっているので、False を返す。\n次の会議の開始時間 が 前の会議の終わり時間より小さい場合ループを続ける。\nループする際、次のリストと比較するため for の range で -1 をする。\nソートをするので Time complexity は O(n log n) となる。\nTime complexity: O(n log n) Mem complexity: O(1)\nclass Solution(object): def canAttendMeetings(self, intervals): \u0026#34;\u0026#34;\u0026#34; :type intervals: List[List[int]] :rtype: bool \u0026#34;\u0026#34;\u0026#34; intervals.sort() for i in range(len(intervals) -1): if intervals[i][1] \u0026gt; intervals[i + 1][0]: return False return True ","permalink":"https://hirotoshimizu.github.io/posts/meeting-rooms/","summary":"https://leetcode.com/problems/meeting-rooms/\n先ず始めに intervals のスタート時間でソートする。\nintervals の時間がソートされたため、 ループで最初の会議の終わりの時間と次の会議の始まりの時間を比較し、 最初の会議の終わりの時間 が 次の会議の始まりの時間より大きい場合、 会議の時間が重なっているので、False を返す。\n次の会議の開始時間 が 前の会議の終わり時間より小さい場合ループを続ける。\nループする際、次のリストと比較するため for の range で -1 をする。\nソートをするので Time complexity は O(n log n) となる。\nTime complexity: O(n log n) Mem complexity: O(1)\nclass Solution(object): def canAttendMeetings(self, intervals): \u0026#34;\u0026#34;\u0026#34; :type intervals: List[List[int]] :rtype: bool \u0026#34;\u0026#34;\u0026#34; intervals.sort() for i in range(len(intervals) -1): if intervals[i][1] \u0026gt; intervals[i + 1][0]: return False return True ","title":"Meeting Rooms"},{"content":"https://leetcode.com/problems/merge-two-sorted-lists/\nダミー Node を作って edge case の 空の Linked List が挿入されても大丈夫なようにする。\nその後はループで l1 と l2 の val を比べ、 小さい値を tail.next に入れる。 その後、 next をずらす。\nループ後 l1, l2 のどちらかのリストが empty の場合、 Linked List に追加する必要があるので、 リストが empty か確認し、値があれば Linked List に追加する。\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeTwoLists(self, l1, l2): \u0026#34;\u0026#34;\u0026#34; :type l1: ListNode :type l2: ListNode :rtype: ListNode \u0026#34;\u0026#34;\u0026#34; dummy = ListNode() tail = dummy while l1 and l2: if l1.val \u0026lt; l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 elif l2: tail.next = 12 return dummy.next ","permalink":"https://hirotoshimizu.github.io/posts/merge-two-sorted-lists/","summary":"https://leetcode.com/problems/merge-two-sorted-lists/\nダミー Node を作って edge case の 空の Linked List が挿入されても大丈夫なようにする。\nその後はループで l1 と l2 の val を比べ、 小さい値を tail.next に入れる。 その後、 next をずらす。\nループ後 l1, l2 のどちらかのリストが empty の場合、 Linked List に追加する必要があるので、 リストが empty か確認し、値があれば Linked List に追加する。\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeTwoLists(self, l1, l2): \u0026#34;\u0026#34;\u0026#34; :type l1: ListNode :type l2: ListNode :rtype: ListNode \u0026#34;\u0026#34;\u0026#34; dummy = ListNode() tail = dummy while l1 and l2: if l1.","title":"Merge Two Sorted Lists"},{"content":"https://leetcode.com/problems/linked-list-cycle/\nLinked List が Cycle なのかを確認する。\nLinked List が Cycle な場合、 2つのポインターを使う。 (1つめのポインターは 1つずつ進み、 2つめのポインターは 2つずつ進む。) Cycle な場合どこかの時点で2つ進むポインター が1つしか進まないポインターに追いつくので Cycle だとわかる。\nCycle ではない場合 いずれかの時点で ポインターが Null になる。\nTime complexity: O(n) Mem complexity: O(1)\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \u0026#34;\u0026#34;\u0026#34; :type head: ListNode :rtype: bool \u0026#34;\u0026#34;\u0026#34; slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if fast == slow: return True return False ","permalink":"https://hirotoshimizu.github.io/posts/linked-list-cycle/","summary":"https://leetcode.com/problems/linked-list-cycle/\nLinked List が Cycle なのかを確認する。\nLinked List が Cycle な場合、 2つのポインターを使う。 (1つめのポインターは 1つずつ進み、 2つめのポインターは 2つずつ進む。) Cycle な場合どこかの時点で2つ進むポインター が1つしか進まないポインターに追いつくので Cycle だとわかる。\nCycle ではない場合 いずれかの時点で ポインターが Null になる。\nTime complexity: O(n) Mem complexity: O(1)\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \u0026#34;\u0026#34;\u0026#34; :type head: ListNode :rtype: bool \u0026#34;\u0026#34;\u0026#34; slow, fast = head, head while fast and fast.","title":"Linked List Cycle"},{"content":"https://leetcode.com/problems/reverse-linked-list/\n考え方としては、\n1 → 2 → 3 → 4 → 5\n1 ← 2 ← 3 ← 4 ← 5\nとするように考える。\n回答方法は iterative なやり方と recursive なやり方がある。 iterative なやり方は 2つの pointer を使う。\nprev と curr\nまず prev に　None を設定する。 curr は head にする\nNull → 1 → 2 → 3 → 4 → 5 ↑ ↑ prev curr\nループしている間 Linked List の 矢印の向き (curr.next) をずらしつつ、prev と next の pointer もずらしていく。\nNull ← 1 → 2 → 3 → 4 → 5 → Null ↑ ↑ prev curr\nNull ← 1 ← 2 → 3 → 4 → 5 → Null ↑ ↑ prev curr\nNull ← 1 ← 2 ← 3 → 4 → 5 → Null ↑ ↑ prev curr\nNull ← 1 ← 2 ← 3 ← 4 → 5 → Null ↑ ↑ prev curr\nNull ← 1 ← 2 ← 3 ← 4 ← 5 → Null ↑ ↑ prev curr\ncurr が Null になりループを抜けるので、 最後に head を prev に設定する。\nTime complexity: O(n) Mem complexity: O(1)\n# Definition for singly-linked list. class ListNode(object): def __init__(self, val=0, next=None): self.val = val self.next = next class Solution(object): def reverseList(self, head): \u0026#34;\u0026#34;\u0026#34; :type head: ListNode :rtype: ListNode \u0026#34;\u0026#34;\u0026#34; prev = None curr = head while curr: nxt = curr.next curr.next = prev prev = curr curr = nxt return prev recursive\nhead: ListNode{val: 1, next: ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}}}} head: ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}}} head: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} head: ListNode{val: 4, next: ListNode{val: 5, next: None}} head: ListNode{val: 5, next: None}\nhead: ListNode{val: 4, next: ListNode{val: 5, next: None}} reversedListHead: ListNode{val: 5, next: None}\nhead: ListNode{val: 4, next: None} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: None}}\nhead: ListNode{val: 3, next: ListNode{val: 4, next: None}} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: None}}\nhead: ListNode{val: 3, next: None} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: None}}}\nhead: ListNode{val: 2, next: ListNode{val: 3, next: None}} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: None}}}\nhead: ListNode{val: 2, next: None} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: ListNode{val: 2, next: None}}}}\nhead: ListNode{val: 1, next: ListNode{val: 2, next: None}} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: ListNode{val: 2, next: None}}}}\nhead: ListNode{val: 1, next: None} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: ListNode{val: 2, next: ListNode{val: 1, next: None}}}}}\nTime complexity: O(n) Mem complexity: O(n)\n","permalink":"https://hirotoshimizu.github.io/posts/reverse-linked-list/","summary":"https://leetcode.com/problems/reverse-linked-list/\n考え方としては、\n1 → 2 → 3 → 4 → 5\n1 ← 2 ← 3 ← 4 ← 5\nとするように考える。\n回答方法は iterative なやり方と recursive なやり方がある。 iterative なやり方は 2つの pointer を使う。\nprev と curr\nまず prev に　None を設定する。 curr は head にする\nNull → 1 → 2 → 3 → 4 → 5 ↑ ↑ prev curr\nループしている間 Linked List の 矢印の向き (curr.next) をずらしつつ、prev と next の pointer もずらしていく。","title":"Reverse Linked List"},{"content":"https://leetcode.com/problems/valid-parentheses/\nPrerequisite Hash Map Stack\n最初にどのカッコがどの 括弧閉じ にマッチしているかわかるために HashMap を作る必要がある。 この際、括弧閉じ をキーにする。\nfor 文で list の中を確認し、 括弧開きは stack に入れる。\nstack は 最後に入れたものから出すので、 括弧開き と 括弧閉じ がマッチしていれば、 stack から pop できる。\n最後に stack に何も残らなければ、 全てがマッチして True を return する。\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def isValid(self, s): \u0026#34;\u0026#34;\u0026#34; :type s: str :rtype: bool \u0026#34;\u0026#34;\u0026#34; stack = [] closeToOpen = { \u0026#39;)\u0026#39; : \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39; : \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39; : \u0026#39;{\u0026#39; } for c in s: if c in closeToOpen: if stack and stack[-1] == closeToOpen[c]: stack.pop() else: return False else: stack.append(c) return True if not stack else False ","permalink":"https://hirotoshimizu.github.io/posts/valid-parentheses/","summary":"https://leetcode.com/problems/valid-parentheses/\nPrerequisite Hash Map Stack\n最初にどのカッコがどの 括弧閉じ にマッチしているかわかるために HashMap を作る必要がある。 この際、括弧閉じ をキーにする。\nfor 文で list の中を確認し、 括弧開きは stack に入れる。\nstack は 最後に入れたものから出すので、 括弧開き と 括弧閉じ がマッチしていれば、 stack から pop できる。\n最後に stack に何も残らなければ、 全てがマッチして True を return する。\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def isValid(self, s): \u0026#34;\u0026#34;\u0026#34; :type s: str :rtype: bool \u0026#34;\u0026#34;\u0026#34; stack = [] closeToOpen = { \u0026#39;)\u0026#39; : \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39; : \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39; : \u0026#39;{\u0026#39; } for c in s: if c in closeToOpen: if stack and stack[-1] == closeToOpen[c]: stack.","title":"Valid Parentheses"},{"content":"https://leetcode.com/problems/missing-number/\nsum([0,1,2,3]) - sum([3,0,1]) = 2 2がない数字なので、2が残る。\n最初に result に len(nums) を代入する。 nums が [3,0,1] の場合、 result に 3 が代入される。\nこれは for で回す時に range(len(nums)) だと 0, 1, 2 としかならないため。 result に len(nums) の代入が必要。\nresult += (i - nums[i]) をすることで、2 が return 出来る。\nTime complexity: O(n) Mem complexity: O(1)\nclass Solution(object): def missingNumber(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; result = len(nums) for i in range(len(nums)): result += (i - nums[i]) return result ","permalink":"https://hirotoshimizu.github.io/posts/missing-number/","summary":"https://leetcode.com/problems/missing-number/\nsum([0,1,2,3]) - sum([3,0,1]) = 2 2がない数字なので、2が残る。\n最初に result に len(nums) を代入する。 nums が [3,0,1] の場合、 result に 3 が代入される。\nこれは for で回す時に range(len(nums)) だと 0, 1, 2 としかならないため。 result に len(nums) の代入が必要。\nresult += (i - nums[i]) をすることで、2 が return 出来る。\nTime complexity: O(n) Mem complexity: O(1)\nclass Solution(object): def missingNumber(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; result = len(nums) for i in range(len(nums)): result += (i - nums[i]) return result ","title":"Missing Number"},{"content":"https://leetcode.com/problems/maximum-subarray/\n | -2 | 1 | -3 | 4 | -1 | 2 | 1 | -5 | 4 | 最初の3つの合計(-2 + 1 -3)はマイナスになるので、 そのため subarray のスタートは 4 もしくは 4以降の数字になる。\n合計が正の数になる場合は保持しておく。 変数に0 を代入して、 iterate しながら数字を追加していく。 合計がマイナスになる場合は保持する必要がないので、0 にする。\nTime complexity: O(n) Mem complexity: O(1)\nclass Solution(object): def maxSubArray(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; max_subarray = nums[0] current_subarray = 0 for n in nums: if current_subarray \u0026lt; 0: current_subarray = 0 current_subarray += n max_subarray = max(max_subarray, current_subarray) return max_subarray ","permalink":"https://hirotoshimizu.github.io/posts/maximum-subarray/","summary":"https://leetcode.com/problems/maximum-subarray/\n | -2 | 1 | -3 | 4 | -1 | 2 | 1 | -5 | 4 | 最初の3つの合計(-2 + 1 -3)はマイナスになるので、 そのため subarray のスタートは 4 もしくは 4以降の数字になる。\n合計が正の数になる場合は保持しておく。 変数に0 を代入して、 iterate しながら数字を追加していく。 合計がマイナスになる場合は保持する必要がないので、0 にする。\nTime complexity: O(n) Mem complexity: O(1)\nclass Solution(object): def maxSubArray(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; max_subarray = nums[0] current_subarray = 0 for n in nums: if current_subarray \u0026lt; 0: current_subarray = 0 current_subarray += n max_subarray = max(max_subarray, current_subarray) return max_subarray ","title":"Maximum Subarray"},{"content":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\npointer を2つ使う。 left が right より低い時点で売る可能性あり。 max_profit に最大の profit を格納。\nright の pointer は右に移動し続け\nleft の　pointer は prices[l] が prices[r] より大きい際に、 left の pointer を right の pointer の位置に移動する。\nTime complexity: O(n)\nMem complexity: O(1)\nclass Solution(object): def maxProfit(self, prices): \u0026#34;\u0026#34;\u0026#34; :type prices: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; l, r = 0, 1 max_profit = 0 while r \u0026lt; len(prices): if prices[l] \u0026lt; prices[r]: profit = prices[r] - prices[l] max_profit = max(max_profit, profit) else: l = r r += 1 return max_profit ","permalink":"https://hirotoshimizu.github.io/posts/best-time-to-buy-and-sell-stock/","summary":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\npointer を2つ使う。 left が right より低い時点で売る可能性あり。 max_profit に最大の profit を格納。\nright の pointer は右に移動し続け\nleft の　pointer は prices[l] が prices[r] より大きい際に、 left の pointer を right の pointer の位置に移動する。\nTime complexity: O(n)\nMem complexity: O(1)\nclass Solution(object): def maxProfit(self, prices): \u0026#34;\u0026#34;\u0026#34; :type prices: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; l, r = 0, 1 max_profit = 0 while r \u0026lt; len(prices): if prices[l] \u0026lt; prices[r]: profit = prices[r] - prices[l] max_profit = max(max_profit, profit) else: l = r r += 1 return max_profit ","title":"Best Time to Buy and Sell Stock"},{"content":"https://leetcode.com/problems/two-sum/\n | 2 | 7 | 11 | 15 | 　↑　↑ 全てのコンビネーションを確認しようと Brute Force で問題を解こうとすると ループの中でループをするのでo(n^2)となる。\n | 2 | 7 | 11 | 15 | そのため HashMapを使う必要がある。 ループして array の中を確認する際に、 HashMap に val と key を持たせる。 ループ時に target - val の値が HashMap にあれば、 合計の値を持つ index が return できる。\n | 2 | 7 | 11 | 15 |  ↑   | HashMap | | val : index | | 2 : 1 |  | HashMap | | val : index | | 2 : 1 | | 7 : 2 |← | 11 : 3 | | 15 : 4 | target は 9 なので val 7 を確認時に HashMap にすでに 2 が入っているので この時点で return できる。\n一度だけのループなので、 Time complexity: O(n) Mem complexity: O(n) となる。\nclass Solution(object): def twoSum(self, nums, target): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; map = {} for i, n in enumerate(nums): diff = target - n if diff in map: return [map[diff], i] map[n] = i ","permalink":"https://hirotoshimizu.github.io/posts/two-sum/","summary":"https://leetcode.com/problems/two-sum/\n | 2 | 7 | 11 | 15 | 　↑　↑ 全てのコンビネーションを確認しようと Brute Force で問題を解こうとすると ループの中でループをするのでo(n^2)となる。\n | 2 | 7 | 11 | 15 | そのため HashMapを使う必要がある。 ループして array の中を確認する際に、 HashMap に val と key を持たせる。 ループ時に target - val の値が HashMap にあれば、 合計の値を持つ index が return できる。\n | 2 | 7 | 11 | 15 |  ↑   | HashMap | | val : index | | 2 : 1 |  | HashMap | | val : index | | 2 : 1 | | 7 : 2 |← | 11 : 3 | | 15 : 4 | target は 9 なので val 7 を確認時に HashMap にすでに 2 が入っているので この時点で return できる。","title":"Two Sum"},{"content":"Responses HttpResponse オブジェクトと違い、レンダリングされたコンテンツでResponseオブジェクトをインスタンス化する必要がない。 その代わりにレンダリングされていないデータをパスする必要がある。\nResponseクラスで使用されるレンダラーは、Djangoモデルインスタンスなどの複雑なデータ型をネイティブに処理できないため、Responseオブジェクトを作成する前に、データをプリミティブデータ型にシリアル化する必要があります。\nREST frameworkのSerializerクラスを使ってこのデータをシリアライズするか、カスタムシリアライザーを使用する。\n引数\n data : レスポンス用のシリアライズされたデータ status : レスポンス用のステータスコード　デフォルトでは 200 template_name : HTMLRenderer が選択されているならテンプレート名 header : レスポンス用の辞書型 HTTP ヘッダー content_type : レスポンス用のコンテンツタイプ。一般的にコンテンツネゴシエーションのrenderer によって自動的に設定される。しかし、場合によっては明示的にコンテンツタイプを特定する必要もある。  プロジェクトが既にある場合 ユーザーモデルは拡張する。\n最初から作成する場合は モデルをオーバーライドして独自のカスタムモデルを作成\nカスタムユーザーモデルは\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-29/","summary":"Responses HttpResponse オブジェクトと違い、レンダリングされたコンテンツでResponseオブジェクトをインスタンス化する必要がない。 その代わりにレンダリングされていないデータをパスする必要がある。\nResponseクラスで使用されるレンダラーは、Djangoモデルインスタンスなどの複雑なデータ型をネイティブに処理できないため、Responseオブジェクトを作成する前に、データをプリミティブデータ型にシリアル化する必要があります。\nREST frameworkのSerializerクラスを使ってこのデータをシリアライズするか、カスタムシリアライザーを使用する。\n引数\n data : レスポンス用のシリアライズされたデータ status : レスポンス用のステータスコード　デフォルトでは 200 template_name : HTMLRenderer が選択されているならテンプレート名 header : レスポンス用の辞書型 HTTP ヘッダー content_type : レスポンス用のコンテンツタイプ。一般的にコンテンツネゴシエーションのrenderer によって自動的に設定される。しかし、場合によっては明示的にコンテンツタイプを特定する必要もある。  プロジェクトが既にある場合 ユーザーモデルは拡張する。\n最初から作成する場合は モデルをオーバーライドして独自のカスタムモデルを作成\nカスタムユーザーモデルは","title":"2021 07 29"},{"content":"APIView REST frameworkは Djangoの View class のサブクラスである、 APIViewclassを提供する。\nAPIViewclass は下記のようにView classとは異なる。\n  handler methods を通ったRequests は REST frameworkの Request インスタンスになり。 Django の HttpRequestインスタンスではない。\n  handler methods の return は REST frameworkの Responseとなり、 その view は content negotiation と response に一致した renderer を返す。\n  どの APIException のエクセプションは正しいレスポンスに仲介される。\n  来るリクエストは認証され、handler methodsに送る前に、 適切な権限やスロットルチェックが行われる。\n  DRF ドキュメント\nViewSet viewSet classは APIViewを継承している。 viewsetで API policy をコントロールするにあたり、 スタンダードの属性であるpermission_classes,authentication_classesが使える。\nviewSet classはどのアクションも含んでいないので、 クラスをオーバーライドして明示的に定義する必要がある。\nDRF ドキュメント\nGenericViewSet GenericViewSetclass は GenericAPIViewを継承して、 デフォルトセットの get_object、get_querysetメソッドと その他の generic view base behaviorを提供する。 しかしデフォルトではどんなアクションも含まれない。\nGenericViewSetを使うにあたり、クラスのオーバーライドと 要求される mixn クラス もしくは、アクションを明示的に定義する必要がある。\nDRF ドキュメント\nModelViewSet ModelViewSet class は GenericAPIView を継承し、さまざまなミックスインクラスの動作を混合することにより、さまざまなアクションの実装を含みます。\nModelViewSet classによって提供されるアクションクラスは .list(),.retrieve(),.create(),.update(),.partial_update(),destroy()\nModelViewSet は GenericAPIViewを拡張しているので、 最低でも queryset と serializer_class属性だけで良い。\n例\nclass AccountViewSet(viewsets.ModelViewSet): \u0026#34;\u0026#34;\u0026#34; A simple ViewSet for viewing and editing accounts. \u0026#34;\u0026#34;\u0026#34; queryset = Account.objects.all() serializer_class = AccountSerializer permission_classes = [IsAccountAdminOrReadOnly] DRF ドキュメント\nMixins mixin クラスは basic view behaviorで使われるアクションを提供する。 mixin　クラスは .get(), .post()などのhabndler method を直接定義するのではなく、アクションメソッドを提供する。これにより柔軟に構成できる。\nmixin クラスは rest_framework.mixinsより import できる。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-28/","summary":"APIView REST frameworkは Djangoの View class のサブクラスである、 APIViewclassを提供する。\nAPIViewclass は下記のようにView classとは異なる。\n  handler methods を通ったRequests は REST frameworkの Request インスタンスになり。 Django の HttpRequestインスタンスではない。\n  handler methods の return は REST frameworkの Responseとなり、 その view は content negotiation と response に一致した renderer を返す。\n  どの APIException のエクセプションは正しいレスポンスに仲介される。\n  来るリクエストは認証され、handler methodsに送る前に、 適切な権限やスロットルチェックが行われる。\n  DRF ドキュメント\nViewSet viewSet classは APIViewを継承している。 viewsetで API policy をコントロールするにあたり、 スタンダードの属性であるpermission_classes,authentication_classesが使える。\nviewSet classはどのアクションも含んでいないので、 クラスをオーバーライドして明示的に定義する必要がある。","title":"2021 07 28"},{"content":"今回は restaurants というアプリを作成し進めていきます。\nCSVのファイルは管理画面のレストランの一覧画面 http://127.0.0.1:8000/admin/restaurants/restaurant/ からアップ。\nアプリの作成\npython manage.py startapp restaurants モデルは restaurant で作成。\nAdmin テンプレートの Override templatesフォルダは manage.py と同じ階層に作成。\ntemplates/admin/restaurants/restaurant/change_list.html を作成\n{% extends \u0026#39;admin/change_list.html\u0026#39; %} {% load static %} {% block content %} \u0026lt;a href=\u0026#34;upload-csv/\u0026#34;\u0026gt;Upload a csv file\u0026lt;/a\u0026gt; {{ block.super }} {% endblock %} {{ block.super }} は親のテンプレートコンテンツ。\nDjango change_list.html\nCustom Admin Page の作成 上記で作成したリンク先の upload-csv/ の URL を設定\nrestaurants/admin.py の RestaurantAdmin で get_urls()を設定。\ndef get_urls(self): urls = super().get_urls() new_urls = [ path(\u0026#39;upload-csv/\u0026#39;, self.upload_csv), ] return new_urls + urls Django ドキュメント\ntemplates/admin/csv_upload.htmlを作成\n{% extends 'admin/base.html' %} {% block content %} \u0026lt;div\u0026gt; \u0026lt;form action=\u0026quot;.\u0026quot; method=\u0026quot;POST\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; {{ form.as_p }} {% csrf_token %} \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Upload File\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; {% endblock %} csvファイルからのテーブル作成 RestaurantAdmin の get_urlsに記載した upload_csv の処理を追加。\ndef upload_csv(self, request): if request.method == \u0026#39;POST\u0026#39;: csv_file = request.FILES[\u0026#39;csv_upload\u0026#39;] file_data = csv_file.read().decode(\u0026#39;utf-8\u0026#39;) restaurants_data = file_data.split(\u0026#39;\\n\u0026#39;) for i in restaurants_data: fields = i.split(\u0026#34;,\u0026#34;) restaurant.objects.update_or_create( name=fields[0], address=fields[1], ) form = CsvImportForm() data = {\u0026#39;form\u0026#39;: form} return render(request, \u0026#39;admin/csv_upload.html\u0026#39;, data) update_or_create() を使用するので、 同じオブジェクトがあればアップデートされ、なければ作成される。\nフォームも必要なので、restaurants/admin.py　にフォームも用意。 class CsvImportForm(forms.Form): csv_upload = forms.FileField()\nこれで最低限のCSVからデータをアップロードできるかと思います。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-19/","summary":"今回は restaurants というアプリを作成し進めていきます。\nCSVのファイルは管理画面のレストランの一覧画面 http://127.0.0.1:8000/admin/restaurants/restaurant/ からアップ。\nアプリの作成\npython manage.py startapp restaurants モデルは restaurant で作成。\nAdmin テンプレートの Override templatesフォルダは manage.py と同じ階層に作成。\ntemplates/admin/restaurants/restaurant/change_list.html を作成\n{% extends \u0026#39;admin/change_list.html\u0026#39; %} {% load static %} {% block content %} \u0026lt;a href=\u0026#34;upload-csv/\u0026#34;\u0026gt;Upload a csv file\u0026lt;/a\u0026gt; {{ block.super }} {% endblock %} {{ block.super }} は親のテンプレートコンテンツ。\nDjango change_list.html\nCustom Admin Page の作成 上記で作成したリンク先の upload-csv/ の URL を設定\nrestaurants/admin.py の RestaurantAdmin で get_urls()を設定。\ndef get_urls(self): urls = super().get_urls() new_urls = [ path(\u0026#39;upload-csv/\u0026#39;, self.","title":"Djnagoの管理画面からCSVファイルをアップしてデータ登録"},{"content":"PrimaryKeyRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのプライマリーキーを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.PrimaryKeyRelatedField(source=\u0026#39;user\u0026#39;, read_only=True) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: 1, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.HyperlinkedRelatedField( source=\u0026#39;user\u0026#39;, # user foreign key lookup_field=\u0026#39;username\u0026#39;, view_name=\u0026#39;api-user:detail\u0026#39;, read_only=True ) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;] view_name  lookup_field リレーション関係にあるターゲット上のフィールド。 参照する view の URL キーワード引数と一致する必要がある。 デフォルトではpk\n \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot;, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user_id = serializers.HyperlinkedRelatedField( source=\u0026#39;user\u0026#39;, # user foreign key lookup_field=\u0026#39;username\u0026#39;, view_name=\u0026#39;api-user:detail\u0026#39;, read_only=True ) user = serializers.SlugRelatedField(read_only=True, slug_field=\u0026#39;username\u0026#39;) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/7/\u0026quot;, \u0026quot;user_id\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/hshimizu/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user\u0026quot;: \u0026quot;hshimizu\u0026quot;, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/hshimizu/images.png\u0026quot; }, DRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-14/","summary":"PrimaryKeyRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのプライマリーキーを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.PrimaryKeyRelatedField(source=\u0026#39;user\u0026#39;, read_only=True) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: 1, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.","title":"2021 07 13"},{"content":"Authenticating users authenticate(request=None, **credentials)\nauthenticate() は認証の承認のために使用する関数。 デフォルトでは keyword arguments で username と password で認証し、 User オブジェクトを返す。\nset_password(raw_password)\nパスワードをハッシュ化するのに使う。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-12/","summary":"Authenticating users authenticate(request=None, **credentials)\nauthenticate() は認証の承認のために使用する関数。 デフォルトでは keyword arguments で username と password で認証し、 User オブジェクトを返す。\nset_password(raw_password)\nパスワードをハッシュ化するのに使う。","title":"2021 07 12"},{"content":"python での JSON の扱いについてわすれるのでメモ。\njson.dumps json.dumps()に入れた変数を JSON string に変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' json.loads json.loads(JSON string) で python dictionary に型を変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' \u0026gt;\u0026gt;\u0026gt; load_json = json.loads(data_json) \u0026gt;\u0026gt;\u0026gt; load_json {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(load_json) \u0026lt;class 'dict'\u0026gt; \u0026gt;\u0026gt;\u0026gt; load_json['abc'] 123 Django Rest Framework\nSerializerでの Create, Update, Delete \u0026quot;\u0026rdquo;\u0026rdquo; Create obj \u0026quot;\u0026rdquo;\u0026rdquo;\ndata = {'user': 1} serializer = StatusSerializer(data=data) serializer.is_valid() # is_validでデータを検証しないと .save() でエラーが出る serializer.save() \u0026quot;\u0026rdquo;\u0026rdquo; Update obj \u0026quot;\u0026rdquo;\u0026rdquo;\nobj = Status.objects.first() data = {'content': 'some new content', 'user': 1} update_serializer = StatusSerializer(obj, data=data) update_serializer.is_valid() update_serializer.save update_serializer.errors {'user': ['This field is required.']} \u0026quot;\u0026rdquo;\u0026rdquo; Delete obj \u0026quot;\u0026rdquo;\u0026rdquo;\nobj = Status.objects.last() obj.delete() Delete は Serializerを使わず、objectを取得して削除。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-11/","summary":"python での JSON の扱いについてわすれるのでメモ。\njson.dumps json.dumps()に入れた変数を JSON string に変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' json.loads json.loads(JSON string) で python dictionary に型を変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' \u0026gt;\u0026gt;\u0026gt; load_json = json.loads(data_json) \u0026gt;\u0026gt;\u0026gt; load_json {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(load_json) \u0026lt;class 'dict'\u0026gt; \u0026gt;\u0026gt;\u0026gt; load_json['abc'] 123 Django Rest Framework","title":"2021 07 11"},{"content":"Web API the good parts\nエンドポイントの基本的な設計 覚えやすく、どんな機能を持つURIなのかがひと目でわかる  短くて入力しやすいURI 人間が読んで理解できるURL 大文字小文字が混在していないURI 改造しやすい（Hackableな）URI サーバー側のアーキテクチャが反映されていないURI  どんなソフトウェア、言語を利用しているのか。 ディレクトリやシステム構成がどうなっているのか。   ルールが統一されたURI  リソースにアクセスするための設計の注意点  複数形の名詞を利用する 利用する単語に気をつける スペースやエンコードを必要とする文字を使わない 単語をつなげる必要がある場合はハイフンを利用する  リソースの一覧取得のエンドポイントが検索を兼ねる。 絞り込み検索はパラメーターを設定する。\n検索に相対位置を利用する問題点 データ数が膨大になるとpageやoffsetを指定されていると「先頭から何件目か」を調べるために先頭から数を数える処理が行われるため遅くなる。 また、更新頻度が高いデータの場合データに不整合が生じる。\n絶対位置でデータを問題点 絶対位置指定とは、オフセットで相対位置を指定する代わりに、これまで取得した最後のデータのIDや時間を記録しておいて、「このIDより前のもの」や「この時刻より古いもの」と言った指定を行う方法。　配列とフォーマット オブジェクトで配列を包むメリット  レスポンスデータが何をしていものかがわかりやすくなる レスポンスデータをオブジェクトに統一することができる。 セキュリティ上のリスクを避けることができる  トップれべるが配列であるJSONは、JSONインジェクションに対するリスクが大きくなる。\n続きがある場合どうデータを返すべきか 例えば20件データを返すためには最大21件の取得を行ってみて、実際に21件取得できれば、 「hasNext」といった名前で結果を含めてあげれば良い。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-09/","summary":"Web API the good parts\nエンドポイントの基本的な設計 覚えやすく、どんな機能を持つURIなのかがひと目でわかる  短くて入力しやすいURI 人間が読んで理解できるURL 大文字小文字が混在していないURI 改造しやすい（Hackableな）URI サーバー側のアーキテクチャが反映されていないURI  どんなソフトウェア、言語を利用しているのか。 ディレクトリやシステム構成がどうなっているのか。   ルールが統一されたURI  リソースにアクセスするための設計の注意点  複数形の名詞を利用する 利用する単語に気をつける スペースやエンコードを必要とする文字を使わない 単語をつなげる必要がある場合はハイフンを利用する  リソースの一覧取得のエンドポイントが検索を兼ねる。 絞り込み検索はパラメーターを設定する。\n検索に相対位置を利用する問題点 データ数が膨大になるとpageやoffsetを指定されていると「先頭から何件目か」を調べるために先頭から数を数える処理が行われるため遅くなる。 また、更新頻度が高いデータの場合データに不整合が生じる。\n絶対位置でデータを問題点 絶対位置指定とは、オフセットで相対位置を指定する代わりに、これまで取得した最後のデータのIDや時間を記録しておいて、「このIDより前のもの」や「この時刻より古いもの」と言った指定を行う方法。　配列とフォーマット オブジェクトで配列を包むメリット  レスポンスデータが何をしていものかがわかりやすくなる レスポンスデータをオブジェクトに統一することができる。 セキュリティ上のリスクを避けることができる  トップれべるが配列であるJSONは、JSONインジェクションに対するリスクが大きくなる。\n続きがある場合どうデータを返すべきか 例えば20件データを返すためには最大21件の取得を行ってみて、実際に21件取得できれば、 「hasNext」といった名前で結果を含めてあげれば良い。","title":"APIの設計"},{"content":"DRFでオブジェクトを作成したとき、 デフォルトで、 作成したオブジェクトを含むディクショナリー型でデータを返す。\nkeys() Pythonの組み込み関数。\nkeys() dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} print(dict.keys()) \u0026gt;\u0026gt;\u0026gt;dict_keys([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} for key in dict.keys(): print(key) \u0026gt;\u0026gt;\u0026gt;A \u0026gt;\u0026gt;\u0026gt;B \u0026gt;\u0026gt;\u0026gt;C getattr Pythonの組み込み関数。\ngetattr(object, name[,default]) 第一引数に指定された object の値を返す。 第二引数の name は文字列である必要があり、文字列が object の属性の一つの名前であった場合、戻り値はその属性の値になる。\nquery_params request.GETと同義語。\nDRF では query_params を使用することを推奨。\nDRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-08/","summary":"DRFでオブジェクトを作成したとき、 デフォルトで、 作成したオブジェクトを含むディクショナリー型でデータを返す。\nkeys() Pythonの組み込み関数。\nkeys() dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} print(dict.keys()) \u0026gt;\u0026gt;\u0026gt;dict_keys([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} for key in dict.keys(): print(key) \u0026gt;\u0026gt;\u0026gt;A \u0026gt;\u0026gt;\u0026gt;B \u0026gt;\u0026gt;\u0026gt;C getattr Pythonの組み込み関数。\ngetattr(object, name[,default]) 第一引数に指定された object の値を返す。 第二引数の name は文字列である必要があり、文字列が object の属性の一つの名前であった場合、戻り値はその属性の値になる。\nquery_params request.GETと同義語。\nDRF では query_params を使用することを推奨。\nDRF ドキュメント","title":"2021 07 08"},{"content":"APIClient APIClientは Djang の Clientクラスを拡張したもの .get()、.post()、.put()、.pathch()、.delete()、.head()、.options()が利用可能。\n例\nfrom rest_framework.test import APIClient client = APIClient() client.post('/notes/', {'title': 'new idea'}, format='json') status from rest_framework import status 人間が読むことができるステータスコードを含む。 テストの際に理解が簡単 github\nrefresh_from_db() モデルのバリューをリフレッシュ使うのに使用。 このメソッドが引数なしで呼ばれると\n モデル上の遅延評価されない全てのフィールドはその時点でデータベース上に存在する値に更新されます。 キャッシュされたリレーションはリロードされたインスタンスに削除される。 Django ドキュメント  force_authenticate() テストする際に強制的に認証をリクエストする\nforce_authenticate(request, user=None, token=None)が呼ばれる時 user か token のいずれか、または両方を設定できる。\nGenericViewSet GenericViewSet クラスは GenericAPIView の継承し、get_object、get_queryset を提供し、デフォルトでは\nGenericViewSetクラスを使用するには、クラスをオーバーライドして、必要なmixinクラスをミックスインするか、アクションの実装を明示的に定義します。\nDRF ドキュメント\nModelSerializer ModelSerializerクラスはSerializer  class とモデルの一致するフィールドを自動で作成する\nModelSerializer クラスは Serializer と同じだが、 *モデルを基にフィールドを自動で作成する *unique_together のようなserializerのためのvalidatorを自動で作成する *デフォルトで .create() .update() 含む。\nmany=True Serializer クラスは serializing もしくは deserializing のリストオブジェクトを扱える。\nserialize する際に many=True を使うことで、queryset もしくはオブジェクトリストをserialize することが出来る。\nperform_create perform_create(self, serializer) は CreateModelMixinが呼ばれたときに新しいオブジェクトを保存する。\nPrimaryKeyRelatedField 例\nclass AlbumSerializer(serializers.ModelSerializer): tracks = serializers.PrimaryKeyRelatedField(many=True, read_only=True) class Meta: model = Album fields = ['album_name', 'artist', 'tracks'] { 'album_name': 'Undun', 'artist': 'The Roots', 'tracks': [ 89, 90, 91, ... ] } DRF ドキュメント\nModelViewSet ModelViewSet クラスは GenericAPIViewを継承。\nModelViewSet クラスは .list(), .retrieve(), .create(), .update(), partial_update(), .destroy()\nDRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/django-rest-framework/","summary":"APIClient APIClientは Djang の Clientクラスを拡張したもの .get()、.post()、.put()、.pathch()、.delete()、.head()、.options()が利用可能。\n例\nfrom rest_framework.test import APIClient client = APIClient() client.post('/notes/', {'title': 'new idea'}, format='json') status from rest_framework import status 人間が読むことができるステータスコードを含む。 テストの際に理解が簡単 github\nrefresh_from_db() モデルのバリューをリフレッシュ使うのに使用。 このメソッドが引数なしで呼ばれると\n モデル上の遅延評価されない全てのフィールドはその時点でデータベース上に存在する値に更新されます。 キャッシュされたリレーションはリロードされたインスタンスに削除される。 Django ドキュメント  force_authenticate() テストする際に強制的に認証をリクエストする\nforce_authenticate(request, user=None, token=None)が呼ばれる時 user か token のいずれか、または両方を設定できる。\nGenericViewSet GenericViewSet クラスは GenericAPIView の継承し、get_object、get_queryset を提供し、デフォルトでは\nGenericViewSetクラスを使用するには、クラスをオーバーライドして、必要なmixinクラスをミックスインするか、アクションの実装を明示的に定義します。\nDRF ドキュメント\nModelSerializer ModelSerializerクラスはSerializer  class とモデルの一致するフィールドを自動で作成する\nModelSerializer クラスは Serializer と同じだが、 *モデルを基にフィールドを自動で作成する *unique_together のようなserializerのためのvalidatorを自動で作成する *デフォルトで .create() .update() 含む。","title":"Django Rest Framework"},{"content":"公開したいページのあるリポジトリの Settings をクリック。\nサイドナビの　Pages をクリック。\n公開したいブランチを選択\n事前にCNAMEでドメインを設定しておいて\n設定したドメインを適用\n","permalink":"https://hirotoshimizu.github.io/posts/host-a-website-on-github/","summary":"公開したいページのあるリポジトリの Settings をクリック。\nサイドナビの　Pages をクリック。\n公開したいブランチを選択\n事前にCNAMEでドメインを設定しておいて\n設定したドメインを適用","title":"GitHub Pages で静的サイトの公開方法"},{"content":"日々学んだ事を記録に残そうと始めました。\nWord Press や Django でブログを作成しようと思いましたが、\n速度やメンテナンスを楽にしたかったので、Hugoで作成。\n設定環境\n Win 10 WSL2 Ubuntu 20.04  1. Hugoのインストール Ubuntuでのインストール\nsudo apt-get install hugo 2. サイトの作成 hugo new site sitename sitename は自分の好きな名前に置き換えてください。\n3. テーマの追加 Hugo のテーマ から好きなテンプレートを選択。\nPaperMod を選択したので、 インストラクションに沿ってgit clone\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. コンテンツの追加 hugo new posts/my-first-post.md --- title: \u0026quot;My First Post\u0026quot; date: 2019-03-26T08:47:11+01:00 draft: true --- ※draft: false に変更で公開\n5. Hugo server を起動 hugo server ","permalink":"https://hirotoshimizu.github.io/posts/how-to-start-hugo/","summary":"日々学んだ事を記録に残そうと始めました。\nWord Press や Django でブログを作成しようと思いましたが、\n速度やメンテナンスを楽にしたかったので、Hugoで作成。\n設定環境\n Win 10 WSL2 Ubuntu 20.04  1. Hugoのインストール Ubuntuでのインストール\nsudo apt-get install hugo 2. サイトの作成 hugo new site sitename sitename は自分の好きな名前に置き換えてください。\n3. テーマの追加 Hugo のテーマ から好きなテンプレートを選択。\nPaperMod を選択したので、 インストラクションに沿ってgit clone\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. コンテンツの追加 hugo new posts/my-first-post.md --- title: \u0026quot;My First Post\u0026quot; date: 2019-03-26T08:47:11+01:00 draft: true --- ※draft: false に変更で公開\n5. Hugo server を起動 hugo server ","title":"Hugo の始め方"},{"content":"このサイトは日々学んだことをメモするためのサイトです。\n","permalink":"https://hirotoshimizu.github.io/about/","summary":"about","title":"about"},{"content":"","permalink":"https://hirotoshimizu.github.io/search/","summary":"search","title":"Search"}]