[{"content":"プロ意識 プロになる前に注意したいこと プロにならないのは簡単だ。自分の仕事に責任を持たなければいい。すべて上司にお任せだ。 ミスをしたら上司が後始末をしてくれる。だた、プロは自分で後始末をする。\n機能に危害を加えてはいけない ソフトウェアをリリースするときには、QAに問題を見つけてもらってはいけない。 不具合がありそうなコードをわざとQAに渡すようでは、プロの風土にも置けない。 では、不具合がありそうなコードとは何だろうか？詳細がわからないコードだ！\nコードが動いていることをどうやって把握するのだろうか？簡単だ。テストすればいい。 何度もテストするのだ。手を変え、品を変え、あらゆる方法でテストするのだ。\nテストには時間がかかりすぎると思っているかもしれない。スケジュールや納期は守らないければいけない。 テストだけやってたらコードが書けないじゃないか。いい指摘だ！\nだからこそ、テストを自動化するんだ。すぐに実行できるユニットテストを何度も実行するんだ。\n本物のプロは、構造を犠牲にして機能を届けるのはバカのやることだと思っている。 コードの柔軟性はその構造にかかっている。構造が不安定ならば未来も不安定になる。 ソフトウェアは適切なコストで変更できなければいけない。\n労働倫理 1週間は168時間だ。雇用主に40時間、君のキャリアに20時間を使える。 残りは108時間。睡眠に56時間を使うとして、残りの52時間は自由に使える。\n自分の専門を知る ソフトウェアのプロが備えるべき最低限のこと\n デザインパターン GOF の 24 のパターンについて説明できる。 POSA のパターンを実際に使える知識がある。 設計原則 SOLID 原則を知っている。コンポーネントの原則を熟知している。 方法論 XP・スクラム・リーン・カンバン・ウォーターフォール・構造化分析・構造化設計を理解している。 規律 TDD・ オブジェクト思考・設計構造化プログラミング・継続的インテグレーション・ペアプログラミングを実践している 成果物 UML・DFD・構造チャート・ペトリネット・状態遷移図・状態遷移表・フローチャート・ディシジョンテーブルの使い方を知っている。  ドメインを知る プログラミングの対象ドメインを理化する責任がある。会計システムを作っているのなら、会計の知識が必要。 ドメインの専門家になる必要はないが、仕事に必要な知識というものがある。\n新しいドメインのプロジェクトが始まるときには、関連書籍を1～2冊読んでみよう。　専門家と一緒に時間を過ごして、彼らの原則や価値を理解しよう。\nビジネスを理解せずに仕様からただコードを書くのはプロとして最低だ。\n仕様の間違いを発見・指摘できるように、ドメインを理解しなければいけない。\n「ノー」と言う 奴隷は「ノー」と言うことを許されていない。労働者は「ノー」と言うことをためらうだろう。 だが、プロは「ノー」と言うことを期待されている。\n反対者の役割 「なぜ」よりも「事実」のほうが重要。\nだが、「なぜ」を説明することで相手の理解が深まり、事実を受け入れてくれることもある。 相手には技術的な知識があり、理解しようとしてくれるならば、理由を説明するのもいいだろう。 だが、理由を説明しても相手が納得しないこともある。 それどころか、あなたが全て悪いと決めつけていまうこともある。 詳細を説明しすぎると、マイクロマネジメントを招いてしまう。\n試しにやってみる 「試しにやってみる」にはさまざまな意味がある。問題にしているのは、「余分な仕事をする」ことだ。 期日に間に合わせるために何かできたのであれば、それまで仕事をしていなかったことになる。 つまり、力を温存していたわけだ。\nもし力を温存していないのんら、もし新しい計画がないのであれば、もし振る舞いを変えないのであれば、もし最初の見積もりに自信があるのであれば、 試しにやってみると約束するのは不誠実である。ウソをついているのと同じだ。おそらくは、自分のメンツを保ち、対立を避けるためにやっているのだろう。\n「イエス」と言う代償 できることなら「イエス」と言いたい。健全なチームはみんなで「イエス」と言うことを目指している。 うまくいっているチームのマネージャーや開発者は、お互いに合意するまで実行計画の内容について交渉する。\nしかし、これまで見てきたように、正しい「イエス」を言うには、「ノー」も恐れずに言わなければいけない。\nコードの実現不可能性 プロはヒーローになることがある。しかし、それはヒーローになろうとしたからではない。 プロは、納期・予算どおりに仕事を成し遂げたときにヒーローになる。\nヒーローになりたい気持ちや「問題を解決」したいと思う気持ちはとても大きい、 我々が意識しておかなければいけないのは、プロの規律を失ってまで「イエス」と言うのは、問題を解決する方法ではないということだ。 規律を失うということは、逆に問題を作り出すことだ。\n約束の言葉 本物の約束を見つけるには、「私が・・・までに・・・をやります」という表現を探すことだ。\nここで重要なのは、「自分で」約束の内容と期日を名言していることだ。 自分以外の誰かの話はしていない。自分がこれからやる行動について話しているのだ。 やる「可能性がある」とか「たぶんやるだろう」ではなく、やり遂げることだ。\n自分でやると言った以上、結果は、やるか、やらないかだ。\nやらなければ、みんなの笑い者になる。自分でもそのことを申し訳なく思うようになる。 やってないと誰かに言うのが気まずくなる。\nプロは頼まれたことすべてに「イエス」と言う必要はない。しかし、「イエス」と言えるような創造的な方法を懸命に探さなければいけない。 プロが「イエス」と言うときには、確実に約束したとわかるような約束の言葉を使っている。\nコーディング コーディングというのは、知的でやりがいはあるが、とても疲れる活動だ。他の仕事では必要とされないようなレベルの集中力が必要になる。 競合する要因を同時に扱わなければいけないからだ。\n 君のコードは、正しく動かなければいけない。そのためには、解決する問題と解決方法を理解しなければいけない。解決策を忠実に反映したコードを書かなければならない。 言語・プラットフォーム・アーキテクチャの一貫性を確保しながら、状況のシステムの欠点と解決策の詳細をうまく管理しなければいけない。 君のコードは、君に代わって顧客の問題を解決しなければいけない。顧客の要求では、問題が解決されないことがよくある。君が調査して、顧客と交渉して、本当のニーズに合わせなければいけない。 君のコードは、既存のシステムに適合しなければいけない。システムの硬直化・脆弱性・不透明性を増やすものであってはいけない。依存性をうまく管理しなければいけない。 つまり、コードはSOLID原則に基づいていなければいけない。 君のコードは、他のプログラマが読みやすいものでなければいけない。コメントをうまく書くという話ではない。君の意図がわかるようにコードを書くということだ。実際にうまくやるのは難しい。 プログラマが習得しなければいけないもののなかで、これが最も難しいことかもしれない。  集中が出来なければコードを間違え、バグを潜り込ませてしまう。構造を間違え不透明で複雑なものになってしまう。 コードにやり直しや手戻りが発生するということだ。集中力が欠けたまま仕事をすると無駄が発生する。\n疲労時や注意散漫のときには、コードを書いてはいけない。やり直しになるだけだ。注意散漫の原因を排除する方法を探して、心を落ち着かせよう。\nバックグランドの心配事が消えないときは、コードを無理やり書くように奮い立たせるのではなく、心配事を作り出している事柄に1時間ほど取り組んでみる。 心配事を減らすことで、バックグランドプロセスを静めることはできる。\n去り際を知る 問題が解決するまで家に帰れないのだろうか？もちろん、帰っていい。むしろ帰るべきだ！ 創造性や知性は、はかない。疲れたらどこかへ消えてしまう。 夜中に働かない脳を酷使して何時間もかけて問題を解決しようとしても、ただ疲れるだけだ。車やシャワーなどの問題解決の機会も減ってしまう。\n疲れてどうしようもなくなったら、しばらく離れてみるといい。創造的な潜在意識で問題を解決してみるのだ。 リソースを節約するように気をつければ、より短い時間で、より少ない労力で、より多くのことができるようになる。\n遅れ 遅れを管理する秘訣は、早期発見と透明性。 最悪なのは、ずっと間に合うと言い続け、最後になってみんなの期待を裏切ることだ。 定期的に進捗を管理して、事実に基づいた3つの期日（最早終了日・通常の終了日・最遅終了日）を求めよう。 3つの期日はできるだけ正直に求めよう。見積もりに願望を含めてはいけない！\nチームとステークホルダーに3つの値を見せよう。そして、毎日更新するのだ。\n","permalink":"https://hirotoshimizu.github.io/posts/clean-coder/","summary":"プロ意識 プロになる前に注意したいこと プロにならないのは簡単だ。自分の仕事に責任を持たなければいい。すべて上司にお任せだ。 ミスをしたら上司が後始末をしてくれる。だた、プロは自分で後始末をする。\n機能に危害を加えてはいけない ソフトウェアをリリースするときには、QAに問題を見つけてもらってはいけない。 不具合がありそうなコードをわざとQAに渡すようでは、プロの風土にも置けない。 では、不具合がありそうなコードとは何だろうか？詳細がわからないコードだ！\nコードが動いていることをどうやって把握するのだろうか？簡単だ。テストすればいい。 何度もテストするのだ。手を変え、品を変え、あらゆる方法でテストするのだ。\nテストには時間がかかりすぎると思っているかもしれない。スケジュールや納期は守らないければいけない。 テストだけやってたらコードが書けないじゃないか。いい指摘だ！\nだからこそ、テストを自動化するんだ。すぐに実行できるユニットテストを何度も実行するんだ。\n本物のプロは、構造を犠牲にして機能を届けるのはバカのやることだと思っている。 コードの柔軟性はその構造にかかっている。構造が不安定ならば未来も不安定になる。 ソフトウェアは適切なコストで変更できなければいけない。\n労働倫理 1週間は168時間だ。雇用主に40時間、君のキャリアに20時間を使える。 残りは108時間。睡眠に56時間を使うとして、残りの52時間は自由に使える。\n自分の専門を知る ソフトウェアのプロが備えるべき最低限のこと\n デザインパターン GOF の 24 のパターンについて説明できる。 POSA のパターンを実際に使える知識がある。 設計原則 SOLID 原則を知っている。コンポーネントの原則を熟知している。 方法論 XP・スクラム・リーン・カンバン・ウォーターフォール・構造化分析・構造化設計を理解している。 規律 TDD・ オブジェクト思考・設計構造化プログラミング・継続的インテグレーション・ペアプログラミングを実践している 成果物 UML・DFD・構造チャート・ペトリネット・状態遷移図・状態遷移表・フローチャート・ディシジョンテーブルの使い方を知っている。  ドメインを知る プログラミングの対象ドメインを理化する責任がある。会計システムを作っているのなら、会計の知識が必要。 ドメインの専門家になる必要はないが、仕事に必要な知識というものがある。\n新しいドメインのプロジェクトが始まるときには、関連書籍を1～2冊読んでみよう。　専門家と一緒に時間を過ごして、彼らの原則や価値を理解しよう。\nビジネスを理解せずに仕様からただコードを書くのはプロとして最低だ。\n仕様の間違いを発見・指摘できるように、ドメインを理解しなければいけない。\n「ノー」と言う 奴隷は「ノー」と言うことを許されていない。労働者は「ノー」と言うことをためらうだろう。 だが、プロは「ノー」と言うことを期待されている。\n反対者の役割 「なぜ」よりも「事実」のほうが重要。\nだが、「なぜ」を説明することで相手の理解が深まり、事実を受け入れてくれることもある。 相手には技術的な知識があり、理解しようとしてくれるならば、理由を説明するのもいいだろう。 だが、理由を説明しても相手が納得しないこともある。 それどころか、あなたが全て悪いと決めつけていまうこともある。 詳細を説明しすぎると、マイクロマネジメントを招いてしまう。\n試しにやってみる 「試しにやってみる」にはさまざまな意味がある。問題にしているのは、「余分な仕事をする」ことだ。 期日に間に合わせるために何かできたのであれば、それまで仕事をしていなかったことになる。 つまり、力を温存していたわけだ。\nもし力を温存していないのんら、もし新しい計画がないのであれば、もし振る舞いを変えないのであれば、もし最初の見積もりに自信があるのであれば、 試しにやってみると約束するのは不誠実である。ウソをついているのと同じだ。おそらくは、自分のメンツを保ち、対立を避けるためにやっているのだろう。\n「イエス」と言う代償 できることなら「イエス」と言いたい。健全なチームはみんなで「イエス」と言うことを目指している。 うまくいっているチームのマネージャーや開発者は、お互いに合意するまで実行計画の内容について交渉する。\nしかし、これまで見てきたように、正しい「イエス」を言うには、「ノー」も恐れずに言わなければいけない。\nコードの実現不可能性 プロはヒーローになることがある。しかし、それはヒーローになろうとしたからではない。 プロは、納期・予算どおりに仕事を成し遂げたときにヒーローになる。","title":"Clean Coder"},{"content":"Chapter 1 Examines the three congnitive processes that play a role when programming and how each is associated with its own type of cunfusion.\n","permalink":"https://hirotoshimizu.github.io/posts/the-programmers-brain/","summary":"Chapter 1 Examines the three congnitive processes that play a role when programming and how each is associated with its own type of cunfusion.","title":"The Programmers Brain"},{"content":"Callable は type hint で関数で呼び出すことが出来る。\nclass PaymentProcessor: def __init__(self, authorize_type: str): if authorizer_type == \u0026#39;sms\u0026#39;: self.authorize = authorize_sms elif authorizer_type == \u0026#39;email\u0026#39;: self.authorize = authorize_email Callable の使い方は list に　実引数のリスト と 返り値の型 を記載する。\nCallable[[引数], 返り値] AuthorizeFunction = Callable[[], bool] class PaymentProcessor: def __init__(self, authorize: AuthorizerFunction): self.authorize = authorize ","permalink":"https://hirotoshimizu.github.io/posts/callable/","summary":"Callable は type hint で関数で呼び出すことが出来る。\nclass PaymentProcessor: def __init__(self, authorize_type: str): if authorizer_type == \u0026#39;sms\u0026#39;: self.authorize = authorize_sms elif authorizer_type == \u0026#39;email\u0026#39;: self.authorize = authorize_email Callable の使い方は list に　実引数のリスト と 返り値の型 を記載する。\nCallable[[引数], 返り値] AuthorizeFunction = Callable[[], bool] class PaymentProcessor: def __init__(self, authorize: AuthorizerFunction): self.authorize = authorize ","title":"Callable"},{"content":"「超」入門失敗の本質 第1章なぜ「戦略」が曖昧なのか？ 戦略のミスは戦術でカバーできない 戦略を実現する方法が「戦術」\nいかに優れた戦術で勝利を生み出しても、最終目標を達成することに結びつかなければ意味はありません。 戦術のミスは戦略でカバーすることができない、とはよく指摘されることですが、目標達成につながらない勝利のために、 戦術をどれほど洗練させても、最終的な目標を達成することはできない。\n戦略とは、いかに「目標達成につながる勝利」を選ぶかを考えること。 日本人は戦略と戦術を混同しやすいが、戦術で勝利しても、最終的な勝利には結びつかない。\n日本は戦略の「指標」が間違っていた 時代や環境が変化しても、同じ行動をとり続ければ優位性を失うように、日本軍は戦場での一大勝利を求めて「白兵銃剣主義」や「艦隊決戦主義」を繰り返し、次第にその威力を失っていく。\n勝利につながる「指標」をいかに選ぶかが戦略である。 性能面や価格で一時的に勝利しても、より有利な指標が現れれば最終的な勝利にはつながらない。\n「体験的学習」では勝った理由はわからない 大局観に欠け、部分のみに固執する日本軍 日本軍ならびに日本企業が歴史上証明してきたことは、必ずしも戦略が先になくとも勝利することができ、ビジネスにおいても成功することができるという驚くべき事実です。\nこれは日本軍にも通じる点ですが、「一点突破・全面展開」という流れを日本人と日本の組織が採用しがちなのは、戦略の定義という意味での論理が先にあるのではなく、体験的学習による察知で「成功する戦略（新指標）を発見している」構造だからでしょう。\n  日本軍 ⋅⋅⋅指標の発見→体験的学習察知（経験から偶然気づく） ⋅⋅⋅勝利に内在する指標を理解せず、再現性がない ⋅⋅⋅成功体験のコピーに陥る。一点突破、全面展開\n  米軍 ⋅⋅⋅指標の発見→勝利にづながる効果的な戦略を選ぶ（敵・味方の行動と結果を分析） ⋅⋅⋅常に戦略があることで勝利を再現性がある ⋅⋅⋅空母・輸送船の撃沈。無意味な戦闘は回避\n  「体験的学習」で一時的に勝利しても、成功要因を把握できないと、長期的には必ず敗北する。指標を理解していない勝利は継続できない。\n第2章なぜ、「日本的思考」は変化に対応できないのか？ 「ゲームのルール変化」に弱い日本組織の仕組み  前提条件が崩れると、新しい戦略を策定できない 新しい概念を創造し、それを活用するという学習法のなさ 目標のための組織ではなく、組織のための目標をつくりがち 異質性や異端を排除しようとする集団文化  品質の高い「個別製品」の零戦部隊が、レーダーという「ビジネスモデル」を搭載した米艦隊に一気に撃墜されてしまうイメージです。\n「練磨」「改善を極めていく」文化を持つ日本人の組織が、現在の世界市場で苦戦する様は、かつての日本軍がその戦闘力を無力化されていく姿に似ている。\nビル・ゲイツやスティーブ・ジョブズのような経営者が、日本でうまれないのは、ルール自体を変えるような破壊的な発送ではなく、型の習熟と改善を基本とする日本的思考と関係している。\n既存の枠組みを超えて「達人の努力を無効にする」革新型の組織は、「人」「技術」「技術の運用」の三つの創造的破壊により、ゲームを根底から変えてしまう。\n「ダブル・ループ学習」で問題解決にあたる 「目標と問題構造を所与ないし一定とした」上で最適解を選び出す学習プロセスを、「シングル・ループ学習」という。 「シングル・ループ学習」は、目標や問題の基本構造が、自らの想定とは違っている、という疑問を持たないスタイルです。\n「ダブル・ループ学習」とは、「想定した目標自体が違っている」のではないか、という疑問・検討を含めた学習スタイルを指す。\nダブル・ループ学習で疑問符をフィードバックする仕組みを持つ。「部下が努力しないからダメだ！」と叱る前に問題の全体像をリーダーや組織が正確に理解しているか、再確認が必要である。\n第3章なぜ、「イノベーション」が生まれないのか？ ","permalink":"https://hirotoshimizu.github.io/posts/the-essence-of-failure/","summary":"「超」入門失敗の本質 第1章なぜ「戦略」が曖昧なのか？ 戦略のミスは戦術でカバーできない 戦略を実現する方法が「戦術」\nいかに優れた戦術で勝利を生み出しても、最終目標を達成することに結びつかなければ意味はありません。 戦術のミスは戦略でカバーすることができない、とはよく指摘されることですが、目標達成につながらない勝利のために、 戦術をどれほど洗練させても、最終的な目標を達成することはできない。\n戦略とは、いかに「目標達成につながる勝利」を選ぶかを考えること。 日本人は戦略と戦術を混同しやすいが、戦術で勝利しても、最終的な勝利には結びつかない。\n日本は戦略の「指標」が間違っていた 時代や環境が変化しても、同じ行動をとり続ければ優位性を失うように、日本軍は戦場での一大勝利を求めて「白兵銃剣主義」や「艦隊決戦主義」を繰り返し、次第にその威力を失っていく。\n勝利につながる「指標」をいかに選ぶかが戦略である。 性能面や価格で一時的に勝利しても、より有利な指標が現れれば最終的な勝利にはつながらない。\n「体験的学習」では勝った理由はわからない 大局観に欠け、部分のみに固執する日本軍 日本軍ならびに日本企業が歴史上証明してきたことは、必ずしも戦略が先になくとも勝利することができ、ビジネスにおいても成功することができるという驚くべき事実です。\nこれは日本軍にも通じる点ですが、「一点突破・全面展開」という流れを日本人と日本の組織が採用しがちなのは、戦略の定義という意味での論理が先にあるのではなく、体験的学習による察知で「成功する戦略（新指標）を発見している」構造だからでしょう。\n  日本軍 ⋅⋅⋅指標の発見→体験的学習察知（経験から偶然気づく） ⋅⋅⋅勝利に内在する指標を理解せず、再現性がない ⋅⋅⋅成功体験のコピーに陥る。一点突破、全面展開\n  米軍 ⋅⋅⋅指標の発見→勝利にづながる効果的な戦略を選ぶ（敵・味方の行動と結果を分析） ⋅⋅⋅常に戦略があることで勝利を再現性がある ⋅⋅⋅空母・輸送船の撃沈。無意味な戦闘は回避\n  「体験的学習」で一時的に勝利しても、成功要因を把握できないと、長期的には必ず敗北する。指標を理解していない勝利は継続できない。\n第2章なぜ、「日本的思考」は変化に対応できないのか？ 「ゲームのルール変化」に弱い日本組織の仕組み  前提条件が崩れると、新しい戦略を策定できない 新しい概念を創造し、それを活用するという学習法のなさ 目標のための組織ではなく、組織のための目標をつくりがち 異質性や異端を排除しようとする集団文化  品質の高い「個別製品」の零戦部隊が、レーダーという「ビジネスモデル」を搭載した米艦隊に一気に撃墜されてしまうイメージです。\n「練磨」「改善を極めていく」文化を持つ日本人の組織が、現在の世界市場で苦戦する様は、かつての日本軍がその戦闘力を無力化されていく姿に似ている。\nビル・ゲイツやスティーブ・ジョブズのような経営者が、日本でうまれないのは、ルール自体を変えるような破壊的な発送ではなく、型の習熟と改善を基本とする日本的思考と関係している。\n既存の枠組みを超えて「達人の努力を無効にする」革新型の組織は、「人」「技術」「技術の運用」の三つの創造的破壊により、ゲームを根底から変えてしまう。\n「ダブル・ループ学習」で問題解決にあたる 「目標と問題構造を所与ないし一定とした」上で最適解を選び出す学習プロセスを、「シングル・ループ学習」という。 「シングル・ループ学習」は、目標や問題の基本構造が、自らの想定とは違っている、という疑問を持たないスタイルです。\n「ダブル・ループ学習」とは、「想定した目標自体が違っている」のではないか、という疑問・検討を含めた学習スタイルを指す。\nダブル・ループ学習で疑問符をフィードバックする仕組みを持つ。「部下が努力しないからダメだ！」と叱る前に問題の全体像をリーダーや組織が正確に理解しているか、再確認が必要である。\n第3章なぜ、「イノベーション」が生まれないのか？ ","title":"The Essence of Failure"},{"content":"ステートメントの関数内への移動 動機 重複の除去は、健全なコードを導くための最もすぐれた経験則の1つ。特定の関数を呼び出すたびに同じコードが実行されていたら、反復コードを関数自体に組み込むことを検討する。 そうすることで、反復コードに将来変更が生じた場合でも、1箇所だけを修正すれば全ての呼び出し側で使えるようになる。将来、反復コードに差異が発生した場合は、「ステートメントの呼び出し側への移動」を行うことで、反復コード（またはその一部）を簡単に元の場所に移動できます。\nステートメントを関数に移動するのは、それを呼び出し先の関数の一部とみなすほうが理解しやすい場合です。呼び出し先の関数の一部としては意味をなさないものの、一緒に呼び出す必要がある場合は、そのステートメントと呼び出し先の関数を対象にして「関数の抽出」を行う。\n手順  反復コードが移動先の関数呼び出しに隣接していない場合は、「ステートメントのスライド」を行って隣接させる。 移動元の関数の呼び出し元が関数だけだった場合は、移動元の関数からコードをカットし、移動先の関数にペーストして、テストを行い、残りの手順を無視する。 複数の呼び出し元がある場合は、いずれかの呼び出しに対して「関数の抽出」を行い、移動先の関数呼び出しと移動したいステートメントを抽出する。名前は一時的なものにするが、簡単に grep できる名前にする。 他のすべての呼び出しを変更して、新しい関数を使うようにする。変更のたびにテストする。 元の呼び出しの全てで新しい関数を使うようになったら、「関数のインライン化」を行って元の関数を新しい関数に完全にインライン化し、元の関数を削除。 「関数名の変更」を行って、新しい関数の名前を元の関数と同じ名前に変更する。  ","permalink":"https://hirotoshimizu.github.io/posts/move-statements-into-function/","summary":"ステートメントの関数内への移動 動機 重複の除去は、健全なコードを導くための最もすぐれた経験則の1つ。特定の関数を呼び出すたびに同じコードが実行されていたら、反復コードを関数自体に組み込むことを検討する。 そうすることで、反復コードに将来変更が生じた場合でも、1箇所だけを修正すれば全ての呼び出し側で使えるようになる。将来、反復コードに差異が発生した場合は、「ステートメントの呼び出し側への移動」を行うことで、反復コード（またはその一部）を簡単に元の場所に移動できます。\nステートメントを関数に移動するのは、それを呼び出し先の関数の一部とみなすほうが理解しやすい場合です。呼び出し先の関数の一部としては意味をなさないものの、一緒に呼び出す必要がある場合は、そのステートメントと呼び出し先の関数を対象にして「関数の抽出」を行う。\n手順  反復コードが移動先の関数呼び出しに隣接していない場合は、「ステートメントのスライド」を行って隣接させる。 移動元の関数の呼び出し元が関数だけだった場合は、移動元の関数からコードをカットし、移動先の関数にペーストして、テストを行い、残りの手順を無視する。 複数の呼び出し元がある場合は、いずれかの呼び出しに対して「関数の抽出」を行い、移動先の関数呼び出しと移動したいステートメントを抽出する。名前は一時的なものにするが、簡単に grep できる名前にする。 他のすべての呼び出しを変更して、新しい関数を使うようにする。変更のたびにテストする。 元の呼び出しの全てで新しい関数を使うようになったら、「関数のインライン化」を行って元の関数を新しい関数に完全にインライン化し、元の関数を削除。 「関数名の変更」を行って、新しい関数の名前を元の関数と同じ名前に変更する。  ","title":"Move Statements Into Function"},{"content":"フィールドの移動 動機 データ構造が正しくないとわかったら、すぐに変更することが重要です。データ構造の欠陥を放置すると、その後長きにわたって、思考を混乱させ、コードを複雑化する原因となる。\nあるレコードを関数に渡す際に、必ず別レコードのフィールドも渡す必要がある場合、フィールドを移動したくなります。まとめて関数に渡すデータは、通常なら同じレコードにまとめるべきで、それによりデータの関係が明確になる。あるレコードを更新するたびに別レコードのフィールドも更新していることは、フィールドの場所が間違っていることを示唆している。複数の場所にある同じフィールドを更新しなければならないことは、フィールドを別の場所に移動して一度だけで更新できるようにすべきことを示している。\nフィールドの移動は、通常、より広範囲な変更の一部として行います。フィールドの移動が完了すると、そのフィールドの利用プログラムの多くにとっては、移動先のオブジェクトのほうが移動元よりも適切なデータのアクセス先となる。しかし、そのリファクタリングは後回しにする。別のケースとして、データの利用方法がネックになり、その時点では「フィールドの移動」を行えない場合がある。そうしたときには最初にデータの利用側をリファクタリングし、その後でフィールドを移動する必要がある。\n手順  移動元のフィールドをカプセル化する。 テスト 移動先にフィールド（およびアクセサ）を作成する。 静的解析を実行する。 移動元のオブジェクトから移動先のオブジェクトを参照できるようにする。 移動先への参照として、既存のフィールドやメソッドが使えるかもしれない。使えない場合は、参照用メソッドを簡単に作れるかどうかを調べる。うまくいかない場合は、移動元のオブジェクトに移動先のオブジェクトを格納する新しいフィールドを作成する必要があるかもしれない。これを恒久的な変更としてもよいが、より広範囲のリファクタリングがある程度進むまでの一時的な変更としてもよい。 移動先のフィールドを使うようにアクセサを調整する。 移動先のオブジェクトが移動元のオブジェクト間で共有される場合は、移動先と移動元の両方のフィールドを更新するように setter を変更した上で「アサーションの導入」を施し矛盾する更新を検出できるようにする。矛盾する更新がないと判断できたら、移動先のフィールドを使うようにアクセサを変更する。 テスト 移動元のフィールドを削除する。 テスト  ","permalink":"https://hirotoshimizu.github.io/posts/move-field/","summary":"フィールドの移動 動機 データ構造が正しくないとわかったら、すぐに変更することが重要です。データ構造の欠陥を放置すると、その後長きにわたって、思考を混乱させ、コードを複雑化する原因となる。\nあるレコードを関数に渡す際に、必ず別レコードのフィールドも渡す必要がある場合、フィールドを移動したくなります。まとめて関数に渡すデータは、通常なら同じレコードにまとめるべきで、それによりデータの関係が明確になる。あるレコードを更新するたびに別レコードのフィールドも更新していることは、フィールドの場所が間違っていることを示唆している。複数の場所にある同じフィールドを更新しなければならないことは、フィールドを別の場所に移動して一度だけで更新できるようにすべきことを示している。\nフィールドの移動は、通常、より広範囲な変更の一部として行います。フィールドの移動が完了すると、そのフィールドの利用プログラムの多くにとっては、移動先のオブジェクトのほうが移動元よりも適切なデータのアクセス先となる。しかし、そのリファクタリングは後回しにする。別のケースとして、データの利用方法がネックになり、その時点では「フィールドの移動」を行えない場合がある。そうしたときには最初にデータの利用側をリファクタリングし、その後でフィールドを移動する必要がある。\n手順  移動元のフィールドをカプセル化する。 テスト 移動先にフィールド（およびアクセサ）を作成する。 静的解析を実行する。 移動元のオブジェクトから移動先のオブジェクトを参照できるようにする。 移動先への参照として、既存のフィールドやメソッドが使えるかもしれない。使えない場合は、参照用メソッドを簡単に作れるかどうかを調べる。うまくいかない場合は、移動元のオブジェクトに移動先のオブジェクトを格納する新しいフィールドを作成する必要があるかもしれない。これを恒久的な変更としてもよいが、より広範囲のリファクタリングがある程度進むまでの一時的な変更としてもよい。 移動先のフィールドを使うようにアクセサを調整する。 移動先のオブジェクトが移動元のオブジェクト間で共有される場合は、移動先と移動元の両方のフィールドを更新するように setter を変更した上で「アサーションの導入」を施し矛盾する更新を検出できるようにする。矛盾する更新がないと判断できたら、移動先のフィールドを使うようにアクセサを変更する。 テスト 移動元のフィールドを削除する。 テスト  ","title":"Move Field"},{"content":"関数の移動 動機 関数を移動する最も直観的な理由は、その関数が存在するコンテキストの要素よりも他のコンテキストの要素を多く参照しえちる場合。移動によって、関数をそれらの要素と一緒にすると、カプセル化が改善することがよくある。別の関数内で定義されたヘルパー関数が単体で有用な場合は、よりアクセスしやすい場所に移動すると有意義。 関数の移動の判断はたいてい困難を伴います。その判断を下すには、その関数の現在のコンテキストを移動先候補のコンテキストを調べます。どの関数が移動したい関数を呼び出すか、移動したい関数がどのデータを使っているかを調べる必要がある。\n関数のグループのために新しいコンテキストが必要になるケースは多いため、「関数群のクラスへの集約」や「クラスの抽出」によって新しいコンテキストを作成する。関数をどこに配置するのが最適かを決めるのは難しいかもしれませんが、通常はその選択が難しければ難しいほど、配置先を決める重要性は下がる。関数をあるコンテキストに実際に移動してみて、どれだけうまく適合するかを調べることは有意義。うまく適合しなかったしても、後からいつでも移動できる。\n手順  移動対象の関数が現在のコンテキストで使用しているプログラム要素をすべて調べる。それらも移動すべきかどうかを検討する。 呼び出している関数にも移動すべきものがあった場合、通常、まずはその関数から移動する。こうすることで、一連の関数の移動を依存性の低い関数から抽出できる。\n上位レベルの関数がサブ関数群の唯一の呼び出し元だった場合、それらのサブ関数群を上位の関数にインライン化し、移動した後で再抽出してもよい。 選択した関数がポリモーフィックなメソッドかどうかを確認する。 オブジェクト指向言語の場合、スーパークラスとサブクラスに注意する必要がある。 関数を移動先のコンテキストにコピーする。新居となる移動先に関数が適合するように調整する。 コード本体が元のコンテキスト内の要素を使用する場合、それらの要素をパラメータとして渡すか、あるいは元のコンテキストへの参照を渡す必要がある。\n関数を移動すると、新しいコンテキストにうまく適合する別の名前を付けたくなることがよくある。 静的解析を実行する。 元のコンテキストから移動後の関数を参照できるようにする。 テスト 元の関数に対して「関数のインライン化」の適用を検討する。 元の関数は委譲関係として残しても良い。しかし、移動した関数を呼び出し元が簡単に呼び出せるなら、余分な仲介者は取り除くほうが良い。  ","permalink":"https://hirotoshimizu.github.io/posts/move-function/","summary":"関数の移動 動機 関数を移動する最も直観的な理由は、その関数が存在するコンテキストの要素よりも他のコンテキストの要素を多く参照しえちる場合。移動によって、関数をそれらの要素と一緒にすると、カプセル化が改善することがよくある。別の関数内で定義されたヘルパー関数が単体で有用な場合は、よりアクセスしやすい場所に移動すると有意義。 関数の移動の判断はたいてい困難を伴います。その判断を下すには、その関数の現在のコンテキストを移動先候補のコンテキストを調べます。どの関数が移動したい関数を呼び出すか、移動したい関数がどのデータを使っているかを調べる必要がある。\n関数のグループのために新しいコンテキストが必要になるケースは多いため、「関数群のクラスへの集約」や「クラスの抽出」によって新しいコンテキストを作成する。関数をどこに配置するのが最適かを決めるのは難しいかもしれませんが、通常はその選択が難しければ難しいほど、配置先を決める重要性は下がる。関数をあるコンテキストに実際に移動してみて、どれだけうまく適合するかを調べることは有意義。うまく適合しなかったしても、後からいつでも移動できる。\n手順  移動対象の関数が現在のコンテキストで使用しているプログラム要素をすべて調べる。それらも移動すべきかどうかを検討する。 呼び出している関数にも移動すべきものがあった場合、通常、まずはその関数から移動する。こうすることで、一連の関数の移動を依存性の低い関数から抽出できる。\n上位レベルの関数がサブ関数群の唯一の呼び出し元だった場合、それらのサブ関数群を上位の関数にインライン化し、移動した後で再抽出してもよい。 選択した関数がポリモーフィックなメソッドかどうかを確認する。 オブジェクト指向言語の場合、スーパークラスとサブクラスに注意する必要がある。 関数を移動先のコンテキストにコピーする。新居となる移動先に関数が適合するように調整する。 コード本体が元のコンテキスト内の要素を使用する場合、それらの要素をパラメータとして渡すか、あるいは元のコンテキストへの参照を渡す必要がある。\n関数を移動すると、新しいコンテキストにうまく適合する別の名前を付けたくなることがよくある。 静的解析を実行する。 元のコンテキストから移動後の関数を参照できるようにする。 テスト 元の関数に対して「関数のインライン化」の適用を検討する。 元の関数は委譲関係として残しても良い。しかし、移動した関数を呼び出し元が簡単に呼び出せるなら、余分な仲介者は取り除くほうが良い。  ","title":"Move Function"},{"content":"レコードのカプセル化 動機 レコード構造は、一般的な機能で、それらは関連するデータを一緒にグループ化する直観的な方法を提供し、緩いデータの群れの代わりに意味のあるデータ単位を渡すことを可能にする。 変更可能なデータについてはレコード化するよりオブジェクト化した方が良い。オブジェクトであれば、保持されているものを隠蔽し、値すべてに対するメソッドを用意できる。 オブジェクトのユーザーは、どれが保持され、どれが計算されるかを知る必要がない。このカプセル化は名前の変更にも役立つ。フィールド名を変更しても、新たな名前と古い名前の両方のメソッドが使えるため、呼び出し側を徐々に置き換えていくことが可能になる。\n手順  レコードを保持する変数に「変数のカプセル化」を施す。 コード名をカプセル化するための関数には、検索しやすい名前を付ける。 変数の中身を、レコードをラップする簡単なクラスに置き換える。レコードをそのまま返すアクセサをクラスに定義する。変数をカプセル化する関数を変更して、アクセサを使うようにする。 テスト レコードそのものではなくオブジェクトを返す関数を用意する。 レコードの使用箇所ごとに、レコードを返す関数の呼び出しを、オブジェクトを返す関数の呼び出しに置き換える。フィールドデータの取得にはオブジェクトのアクセサを使うようにする。必要ならばそのためのアクセサを作る。変更のたびにテストする。 入れ子構造を持つなど、レコードが複雑な場合は、まずデータを更新しているクライアントのコードに注目する。データを読むだけのクライアントについては、コピーやプロキシを返すことを検討する。 生データへのアクセサと、検索しやすくしておいたレコードそのままを返す関数をクラスから取り除く。 テスト レコードのフィールド自体が構造体である場合、「レコードのカプセル化」と「コレクションのカプセル化」を再帰的に施すことを検討する。  ","permalink":"https://hirotoshimizu.github.io/posts/encapsulate-record/","summary":"レコードのカプセル化 動機 レコード構造は、一般的な機能で、それらは関連するデータを一緒にグループ化する直観的な方法を提供し、緩いデータの群れの代わりに意味のあるデータ単位を渡すことを可能にする。 変更可能なデータについてはレコード化するよりオブジェクト化した方が良い。オブジェクトであれば、保持されているものを隠蔽し、値すべてに対するメソッドを用意できる。 オブジェクトのユーザーは、どれが保持され、どれが計算されるかを知る必要がない。このカプセル化は名前の変更にも役立つ。フィールド名を変更しても、新たな名前と古い名前の両方のメソッドが使えるため、呼び出し側を徐々に置き換えていくことが可能になる。\n手順  レコードを保持する変数に「変数のカプセル化」を施す。 コード名をカプセル化するための関数には、検索しやすい名前を付ける。 変数の中身を、レコードをラップする簡単なクラスに置き換える。レコードをそのまま返すアクセサをクラスに定義する。変数をカプセル化する関数を変更して、アクセサを使うようにする。 テスト レコードそのものではなくオブジェクトを返す関数を用意する。 レコードの使用箇所ごとに、レコードを返す関数の呼び出しを、オブジェクトを返す関数の呼び出しに置き換える。フィールドデータの取得にはオブジェクトのアクセサを使うようにする。必要ならばそのためのアクセサを作る。変更のたびにテストする。 入れ子構造を持つなど、レコードが複雑な場合は、まずデータを更新しているクライアントのコードに注目する。データを読むだけのクライアントについては、コピーやプロキシを返すことを検討する。 生データへのアクセサと、検索しやすくしておいたレコードそのままを返す関数をクラスから取り除く。 テスト レコードのフィールド自体が構造体である場合、「レコードのカプセル化」と「コレクションのカプセル化」を再帰的に施すことを検討する。  ","title":"Encapsulate Record"},{"content":"フェーズの分離 動機 1つのコードが異なる2つの処理を行っている場合、別々のモジュールに分離する方法がないか探す。 分離に力を咲くのは、トピックごとに分けて対処でき、両方を1度に頭に入れる必要がないから。\n振る舞いを順次的な2段階のフェーズに分けるという方法がある。 処理を始める前に、入力をメイン処理に都合の良い形式に整形する。\n手順  後半となるフェーズのコードを、関数として抽出する。 テスト 抽出した関数に追加される引数として、中間データ構造を導入する。 テスト 抽出した後半のフェーズの各パラメータを確認する。それらが前半のフェーズでも使われているなら、中間データ構造へと移す。1つ移すごとにテストする。 あるパラメータについては後半のフェーズで使うべきでないこともある。その場合は、そのパラメータを使用した結果を、中間データ構造のフィールドとして抽出する。その後「ステートメントの呼び出し側への移動」を施して、この中間データ構造に値を格納している行を移動する。 前半のフェーズのコードに「関数の抽出」を施し、中間データ構造を返すようにする。 前半のフェーズを変換オブジェクトとして抽出してもよい。  ","permalink":"https://hirotoshimizu.github.io/posts/split-phase/","summary":"フェーズの分離 動機 1つのコードが異なる2つの処理を行っている場合、別々のモジュールに分離する方法がないか探す。 分離に力を咲くのは、トピックごとに分けて対処でき、両方を1度に頭に入れる必要がないから。\n振る舞いを順次的な2段階のフェーズに分けるという方法がある。 処理を始める前に、入力をメイン処理に都合の良い形式に整形する。\n手順  後半となるフェーズのコードを、関数として抽出する。 テスト 抽出した関数に追加される引数として、中間データ構造を導入する。 テスト 抽出した後半のフェーズの各パラメータを確認する。それらが前半のフェーズでも使われているなら、中間データ構造へと移す。1つ移すごとにテストする。 あるパラメータについては後半のフェーズで使うべきでないこともある。その場合は、そのパラメータを使用した結果を、中間データ構造のフィールドとして抽出する。その後「ステートメントの呼び出し側への移動」を施して、この中間データ構造に値を格納している行を移動する。 前半のフェーズのコードに「関数の抽出」を施し、中間データ構造を返すようにする。 前半のフェーズを変換オブジェクトとして抽出してもよい。  ","title":"Split Phase"},{"content":"関数群の変換への集約 動機 ソフトウェアの多くは、プログラムにデータを投入して、そこからさまざまな派生情報を計算する処理を含んでいる。派生値はさまざまな箇所で必要になり、派生値が参照されるたびに繰り返される。 こうした派生値はまとめるのが望ましく、一貫した探しやすい場所で更新がおこなわれるようにして、重複したロジックは避けるべき。\nその1つの方法はデータ変換関数を使うことです。これは元データを入力としてすべての派生値を計算し、それらを出力データのフィールドとして設定するものです。そうすることで、派生値について調べたいときは変換関数だけを見ればよくなる。\nもう1つの方法が「関数群のクラスへの集約」。元データに基づいてクラスを構成し、ロジックをそのクラスのメソッドに移す。\n重要な違いは、元データがコード内で更新される場合は、クラスを使うほうが良い。変換関数を使うと派生データが新たなレコードに保持されます。そのため元のデータが変更されると不整合が生じる。\n関数群を集約したい理由として、派生値を求めるロジックの重複をさけたいということがある。それだけなら、単に「関数の抽出」をロジックに適用する手もあるが、関数が扱うデータ構造と近い位置に置かれていないと、関数を見つけ出すのが難しくなる。変換関数を使うと、探すのが容易になり利用もしやすくなる。\n手順  変換されるレコードを入力とし、同じ値を返す変換関数を作る。\n通常、この関数の中ではレコードのディープコピーが行われる。この変換によって元のレコードが変更されていないことを確認するテストを書くとよい。 ロジックを選んでその本体を変換関数側に移し、レコードに新たなフィールドを設ける。そのフィールドを使うようにクライアント側のコードを変更する。 ロジックが複雑ならば、まず「関数の抽出」を施す。 テスト その他の関連した関数群について上記の手順を繰り返す。  ","permalink":"https://hirotoshimizu.github.io/posts/combine-functions-transform/","summary":"関数群の変換への集約 動機 ソフトウェアの多くは、プログラムにデータを投入して、そこからさまざまな派生情報を計算する処理を含んでいる。派生値はさまざまな箇所で必要になり、派生値が参照されるたびに繰り返される。 こうした派生値はまとめるのが望ましく、一貫した探しやすい場所で更新がおこなわれるようにして、重複したロジックは避けるべき。\nその1つの方法はデータ変換関数を使うことです。これは元データを入力としてすべての派生値を計算し、それらを出力データのフィールドとして設定するものです。そうすることで、派生値について調べたいときは変換関数だけを見ればよくなる。\nもう1つの方法が「関数群のクラスへの集約」。元データに基づいてクラスを構成し、ロジックをそのクラスのメソッドに移す。\n重要な違いは、元データがコード内で更新される場合は、クラスを使うほうが良い。変換関数を使うと派生データが新たなレコードに保持されます。そのため元のデータが変更されると不整合が生じる。\n関数群を集約したい理由として、派生値を求めるロジックの重複をさけたいということがある。それだけなら、単に「関数の抽出」をロジックに適用する手もあるが、関数が扱うデータ構造と近い位置に置かれていないと、関数を見つけ出すのが難しくなる。変換関数を使うと、探すのが容易になり利用もしやすくなる。\n手順  変換されるレコードを入力とし、同じ値を返す変換関数を作る。\n通常、この関数の中ではレコードのディープコピーが行われる。この変換によって元のレコードが変更されていないことを確認するテストを書くとよい。 ロジックを選んでその本体を変換関数側に移し、レコードに新たなフィールドを設ける。そのフィールドを使うようにクライアント側のコードを変更する。 ロジックが複雑ならば、まず「関数の抽出」を施す。 テスト その他の関連した関数群について上記の手順を繰り返す。  ","title":"Combine Functions Transform"},{"content":"関数群のクラスへの集約 動機 共通のデータに対して互いに関わりの深い処理を行う一群の関数があれば、クラスを定義するチャンスと考える。（共通データは通常は関数呼び出しの際に引数として渡さる。）クラスを使うことで、これらの関数が共有する環境がより明示的になり、関数の引数が大幅に減ることで、オブジェクト内の関数呼び出しを単純化できます。そうしたオブジェクトをシステムの他の部分に参照として渡すのも容易になる。\nこのリファクタリングは既存の関数群を体系化するだけではなく、他で断片的に計算を行っている箇所を特定し、新たなクラスのメソッドとしてリファクタリングする良い機会も与えてくれる。\n手順  関数間で共有しているデータのレコードに「レコードのカプセル化」を施す。\n関数間で共有しているデータが、レコード構造としてまとめられていない場合は、「パラメータオブジェクトの導入」を施し、それらをまとめるレコードを作る。 「関数の移動」を適用して、共通のレコードを扱う関数をそれぞれ、新たなクラスへと移す。\n関数呼び出しの引数のうち、クラスのメンバになっているものは、引数のリストから取り除くことができる。 データを操作するロジックの断片があればそれぞれ、「関数の抽出」で抽出してクラスに移す。  ","permalink":"https://hirotoshimizu.github.io/posts/combine-functions-into-class/","summary":"関数群のクラスへの集約 動機 共通のデータに対して互いに関わりの深い処理を行う一群の関数があれば、クラスを定義するチャンスと考える。（共通データは通常は関数呼び出しの際に引数として渡さる。）クラスを使うことで、これらの関数が共有する環境がより明示的になり、関数の引数が大幅に減ることで、オブジェクト内の関数呼び出しを単純化できます。そうしたオブジェクトをシステムの他の部分に参照として渡すのも容易になる。\nこのリファクタリングは既存の関数群を体系化するだけではなく、他で断片的に計算を行っている箇所を特定し、新たなクラスのメソッドとしてリファクタリングする良い機会も与えてくれる。\n手順  関数間で共有しているデータのレコードに「レコードのカプセル化」を施す。\n関数間で共有しているデータが、レコード構造としてまとめられていない場合は、「パラメータオブジェクトの導入」を施し、それらをまとめるレコードを作る。 「関数の移動」を適用して、共通のレコードを扱う関数をそれぞれ、新たなクラスへと移す。\n関数呼び出しの引数のうち、クラスのメンバになっているものは、引数のリストから取り除くことができる。 データを操作するロジックの断片があればそれぞれ、「関数の抽出」で抽出してクラスに移す。  ","title":"Combine Functions Into Class"},{"content":"パラメータオブジェクトの導入 動機 データ構造体にまとめることには意味があり、データ項目間の関係を明示するとができる。 新たな構造体を使えば、関数のパラメータ数は少なくて済みます。その構造体を使うすべての関数が、構造体の要素を取得するのに同じ名前を使うことで、一貫性の向上にも役立ちます。 このリファクタリングの真価は、コードにより深い変化を引き起こすことにあります。新たな構造体を特定したら、その構造体を使うようにプログラムの振る舞いを改めます。一連の共通関数群になることも、データ構造とそれらの関数を組み合わせたクラスになることもあります。この過程でコードの概念的な構図が変化することもある。そうした構造体を新たな抽象に引き上げると、問題領域の理解がすっきりする。\n手順  ふさわしい構造体がまだ存在しないなら、作成する。 後で振る舞いをまとめやすいのでクラスにすることが多い、構造体が「値オブジェクト」なのか確認するとよい。 テスト 関数宣言の変更を施し、新たな構造体用のパラメータを追加する テスト 新たな構造体の正しいインスタンスを渡すように各呼び出し側を修正する。1つの呼び出しを修正するごとにテストする 元のパラメータを使用している箇所を、新たな構造体の要素を使うように1つひとつ置き換える。元のパラメータを削除し、テストする。  ","permalink":"https://hirotoshimizu.github.io/posts/introduce-parameter-object/","summary":"パラメータオブジェクトの導入 動機 データ構造体にまとめることには意味があり、データ項目間の関係を明示するとができる。 新たな構造体を使えば、関数のパラメータ数は少なくて済みます。その構造体を使うすべての関数が、構造体の要素を取得するのに同じ名前を使うことで、一貫性の向上にも役立ちます。 このリファクタリングの真価は、コードにより深い変化を引き起こすことにあります。新たな構造体を特定したら、その構造体を使うようにプログラムの振る舞いを改めます。一連の共通関数群になることも、データ構造とそれらの関数を組み合わせたクラスになることもあります。この過程でコードの概念的な構図が変化することもある。そうした構造体を新たな抽象に引き上げると、問題領域の理解がすっきりする。\n手順  ふさわしい構造体がまだ存在しないなら、作成する。 後で振る舞いをまとめやすいのでクラスにすることが多い、構造体が「値オブジェクト」なのか確認するとよい。 テスト 関数宣言の変更を施し、新たな構造体用のパラメータを追加する テスト 新たな構造体の正しいインスタンスを渡すように各呼び出し側を修正する。1つの呼び出しを修正するごとにテストする 元のパラメータを使用している箇所を、新たな構造体の要素を使うように1つひとつ置き換える。元のパラメータを削除し、テストする。  ","title":"Introduce Parameter Object"},{"content":"変数名の変更 動機 変数はうまく名前を付けさえすれば、目的説明する上で非常に役立ちます。しかし注意深く考えていない場合やユーザーのニーズが変わってプログラムの目的が変わったから、などがあり不適切な名前となることがある。\n手順  変数が広く使われている場合、「変数のカプセル化」を検討する。 変数への参照をくまなく探し、それらをすべて変更数。\n変数が別のコードベースから参照されている場合、その変数は公開されているので、このリファクタリングを行うことはできない。\n変数が変更されない場合、変数を新たな名前の変数にコピーしてから、徐々に置き換えていき、その都度テストする テスト  ","permalink":"https://hirotoshimizu.github.io/posts/rename-variable/","summary":"変数名の変更 動機 変数はうまく名前を付けさえすれば、目的説明する上で非常に役立ちます。しかし注意深く考えていない場合やユーザーのニーズが変わってプログラムの目的が変わったから、などがあり不適切な名前となることがある。\n手順  変数が広く使われている場合、「変数のカプセル化」を検討する。 変数への参照をくまなく探し、それらをすべて変更数。\n変数が別のコードベースから参照されている場合、その変数は公開されているので、このリファクタリングを行うことはできない。\n変数が変更されない場合、変数を新たな名前の変数にコピーしてから、徐々に置き換えていき、その都度テストする テスト  ","title":"Rename Variable"},{"content":"変数のカプセル化 動機 スコープが大きくなるにつれて変更が困難になっていく。そのため広い範囲でデータを移動したいといは、カプセル化して、変数へのアクセスを関数経由にするのが非常に良いやり方。これでデータの再構成という困難な作業を、関数の再構成というより簡単な作業に変えることができる。\nそれ以外にデータの変更や参照を監視できるという明確な利点を得られる。データ更新の際の検証や後処理を追加するのも簡単。\nスコープが1つの関数より大きいものは、関数を通じてのみアクセスできるようにし、データのスコープが大きくなるほどカプセル化はより重要になる。\n手順  変数を参照・更新するためのカプセル化用関数を作る。 静的チェックを実行する。 変数への参照を、1つひとつ適切なカプセル化関数の呼び出しに置き換える。置き換えるごとにテストする。 変数の可視性を制限する。\n変数への直接アクセスを防げないことがよくある。その場合、変数名を変更してテストすることで、置き換えが漏れた参照を見つけることができる。 テスト 変数の値がレコードの場合、「レコードのカプセル化」を検討する。  ","permalink":"https://hirotoshimizu.github.io/posts/encapsulate-variable/","summary":"変数のカプセル化 動機 スコープが大きくなるにつれて変更が困難になっていく。そのため広い範囲でデータを移動したいといは、カプセル化して、変数へのアクセスを関数経由にするのが非常に良いやり方。これでデータの再構成という困難な作業を、関数の再構成というより簡単な作業に変えることができる。\nそれ以外にデータの変更や参照を監視できるという明確な利点を得られる。データ更新の際の検証や後処理を追加するのも簡単。\nスコープが1つの関数より大きいものは、関数を通じてのみアクセスできるようにし、データのスコープが大きくなるほどカプセル化はより重要になる。\n手順  変数を参照・更新するためのカプセル化用関数を作る。 静的チェックを実行する。 変数への参照を、1つひとつ適切なカプセル化関数の呼び出しに置き換える。置き換えるごとにテストする。 変数の可視性を制限する。\n変数への直接アクセスを防げないことがよくある。その場合、変数名を変更してテストすることで、置き換えが漏れた参照を見つけることができる。 テスト 変数の値がレコードの場合、「レコードのカプセル化」を検討する。  ","title":"Encapsulate Variable"},{"content":"関数宣言の変更 動機 関数宣言はソフトウェアシステムにおける継ぎ目となる。多くの部分が継ぎ目に依存し、良い継ぎ目があればシステムに新たな部品を追加するのは簡単。悪い継ぎ目は常に問題の発生源になる。\n継ぎ目の要素で最も重要なのは関数名です。もし間違った名前の関数を見たら、少しでも名前がわかり次第、断固として変更していかなければなりません。\n関数の名前を改善していくための良い方法は、関数の目的をコメントとして書くこと。そのコメントを名前に変更する。\n手順 変更内容を吟味して、宣言と呼び出しとを一度で簡単に変更できるかを検討する。もしできるなら簡易な手順を実行する。 そうでなければ移行手順を選択して呼び出し側より漸進的に変更していく。 この手順が大きな意味を持つのは、呼び出し箇所が多い場合や（公開されたAPIのように）呼び出し箇所が手の届かないところにある場合、関数がポリモーフィックなメソッドである場合、関数宣言に複雑な変更を加える場合です。\n簡易な手順  パラメータを削除する場合、それが関数内部で参照されていないことを確認する。 関数宣言を望ましいものに変更する。 古い関数宣言へのすべての参照を探し、新しいものに変更する。 テスト 名前の変更とパラメータの追加の両方がある場合には、それぞれ別のステップで実施する。  移行手順  必要なら関数の本体をリファクタリングして、移行の抽出のステップを実施しやすくしておく。 関数本体に関数の抽出を施して、新たな関数を作る。\n新たな関数の名前を古いものと同じにする予定なら、新たな関数に判別しやすい名前を一時的に付けておく。 抽出した関数が追加のパラメータを必要とする場合、簡易な手順により追加を行う。 古い関数に「関数のインライン化」を施す。 一時的な名前を使った場合、「関数宣言の変更」を再び実施し、元の名前に戻す。 テスト  ","permalink":"https://hirotoshimizu.github.io/posts/change-function-declaration/","summary":"関数宣言の変更 動機 関数宣言はソフトウェアシステムにおける継ぎ目となる。多くの部分が継ぎ目に依存し、良い継ぎ目があればシステムに新たな部品を追加するのは簡単。悪い継ぎ目は常に問題の発生源になる。\n継ぎ目の要素で最も重要なのは関数名です。もし間違った名前の関数を見たら、少しでも名前がわかり次第、断固として変更していかなければなりません。\n関数の名前を改善していくための良い方法は、関数の目的をコメントとして書くこと。そのコメントを名前に変更する。\n手順 変更内容を吟味して、宣言と呼び出しとを一度で簡単に変更できるかを検討する。もしできるなら簡易な手順を実行する。 そうでなければ移行手順を選択して呼び出し側より漸進的に変更していく。 この手順が大きな意味を持つのは、呼び出し箇所が多い場合や（公開されたAPIのように）呼び出し箇所が手の届かないところにある場合、関数がポリモーフィックなメソッドである場合、関数宣言に複雑な変更を加える場合です。\n簡易な手順  パラメータを削除する場合、それが関数内部で参照されていないことを確認する。 関数宣言を望ましいものに変更する。 古い関数宣言へのすべての参照を探し、新しいものに変更する。 テスト 名前の変更とパラメータの追加の両方がある場合には、それぞれ別のステップで実施する。  移行手順  必要なら関数の本体をリファクタリングして、移行の抽出のステップを実施しやすくしておく。 関数本体に関数の抽出を施して、新たな関数を作る。\n新たな関数の名前を古いものと同じにする予定なら、新たな関数に判別しやすい名前を一時的に付けておく。 抽出した関数が追加のパラメータを必要とする場合、簡易な手順により追加を行う。 古い関数に「関数のインライン化」を施す。 一時的な名前を使った場合、「関数宣言の変更」を再び実施し、元の名前に戻す。 テスト  ","title":"Change Function Declaration"},{"content":"関数のインライン化 動機 意図がわかるように命名された短い関数を使うことはコードを読みやすくする。しかし、関数の本体がその名前と同じくらいわかりやすいことがある。そうしたときには関数を取り除く。\n「関数のインライン化」は、うまく分割できない関数群があるときにも使われる。こうしたときは、それらを1つの大きな関数にインライン化してから、望ましい形の関数群として再抽出すればよい。\n通常、「関数のインライン化」を使うのは、間接化しすぎた結果、どの関数も別の関数へ委譲しているだけにしか見えず、委譲に次ぐ委譲の途中で迷っている状態。\n手順  関数がポリモーフィックなメソッドでないことを確認する。\nクラスのメソッドで、サブクラスでオーバーライドされている場合はインライン化できない。 この関数の呼び出し元をすべて見つける。 関数の各呼び出し元をすべて見つける。 1つ置き換えるごとにですとする。\nすべてのインライン化を一度にする必要はない。一部のインライン化がやりにくいようなら、機会を持って徐々に進めてもよい。 関数の定義を取り除く   Before def say_state(self): print_state(self) def print_state(self): print(f\u0026#34;I\u0026#39;m going {self.speed} kph!\u0026#34;) After def say_state(self): print(\u0026#34;I\u0026#39;m going {} kph!\u0026#34;.format(self.speed)) ","permalink":"https://hirotoshimizu.github.io/posts/inline-function/","summary":"関数のインライン化 動機 意図がわかるように命名された短い関数を使うことはコードを読みやすくする。しかし、関数の本体がその名前と同じくらいわかりやすいことがある。そうしたときには関数を取り除く。\n「関数のインライン化」は、うまく分割できない関数群があるときにも使われる。こうしたときは、それらを1つの大きな関数にインライン化してから、望ましい形の関数群として再抽出すればよい。\n通常、「関数のインライン化」を使うのは、間接化しすぎた結果、どの関数も別の関数へ委譲しているだけにしか見えず、委譲に次ぐ委譲の途中で迷っている状態。\n手順  関数がポリモーフィックなメソッドでないことを確認する。\nクラスのメソッドで、サブクラスでオーバーライドされている場合はインライン化できない。 この関数の呼び出し元をすべて見つける。 関数の各呼び出し元をすべて見つける。 1つ置き換えるごとにですとする。\nすべてのインライン化を一度にする必要はない。一部のインライン化がやりにくいようなら、機会を持って徐々に進めてもよい。 関数の定義を取り除く   Before def say_state(self): print_state(self) def print_state(self): print(f\u0026#34;I\u0026#39;m going {self.speed} kph!\u0026#34;) After def say_state(self): print(\u0026#34;I\u0026#39;m going {} kph!\u0026#34;.format(self.speed)) ","title":"Inline Function"},{"content":"睡眠こそ最強の解決策である なぜ朝型人間と夜型人間がいるのか 朝型と夜型の分類は、「クロノタイプ」とも呼ばれている。大人の場合、クロノタイプはほぼ遺伝で決まることが多い。\n午後のコーヒーが夜の睡眠を奪う 睡眠と覚醒を決める要素は2つあり、24時間単位の概日リズムはその最初の1つだ。そして2つ目の要素が「睡眠圧」になる。今この瞬間も、あなたの脳内では、「アデノシン」と呼ばれる化学物質が着々と増えている。アデノシンの増加は、起きている間ずっと続いている。だから起きている時間が長くなるほど、脳内のアデノシンも多くなるということだ。アデノシンは、起きている時間を計測する装置だという考え方もできる。\n脳内のアデノシンが増えると、眠りたいという欲求が高まる。この現象が「睡眠圧」だ。脳内に蓄積されたアデノシンは、脳の覚醒を司る部位のボリュームを下げ、睡眠を司る部分のボリュームをあげるという、2つの技を同時にこなすことができる。アデノシンの量がピークに達すると、もう眠くて眠くてたまらないという状態だ。たいていの人は、12時間から16時間起きているとこの状態になる。\nしかし、ある種の化学物質を使えば、アデノシンから出る睡眠信号を消し、眠気を覚ますことができる。その物質が「カフェイン」だ。\nカフェインの半減期は、平均して5時間から7時間になる。たとえば午後7時30頃に夕食のコーヒーを1杯飲んだとすると、午前1時30分になってもまだ半分のカフェインが体内に残っていることになる。\nなぜ深い眠りと浅い眠りがあるのか 深いノンレム睡眠のいちばん大切な機能は、もういらなくなったニューロンのつながりを削除することだ。対照的に夢を見るレム睡眠は、ニューロンのつながりを強化する役割をはたしている。\n2つの睡眠で記憶スペースの容量不足を解消する 粘土を使って像を造ると想像してみよう。まず、大きな粘土のかたまりを台座に置く。大きな粘土のかたまりは、寝るまでに脳内に蓄積されたすべの記憶にあたる。次に、粘土のかたまりを削り、大まかな形にしていく。これが長時間続くノンレム睡眠だ。その間に、細部の造形を行うこともある（短いレム睡眠）。\nこの最初の段階が終わると、また粘土を大まかに削る作業が始まる（2度目の長いノンレム睡眠）、それからさらに細部をつくり込んでいく（先ほどより少し長いレム睡眠）。このサイクルを何度か繰り返すと、求められる作業のバランスが変わる。大まかに削る作業はほぼ終わり、今度は細部のつくり込みがメインになる（レム睡眠が大半を占め、ノンレム睡眠の出番はほとんどなくなる）。\nこのように、睡眠は巧みな技を使って、記憶スペースの容量不足という問題を解決している。\nノンレム睡眠で情報を整理し、レム睡眠で情報を統合する 深い眠りのゆっくりした脳波が、短期の記憶が保管されている場所から新しい記憶の入った荷物を受け取り、長期の記憶を保管する場所に届けている。\n覚醒時の脳波の役割が、外側の情報を受け取ることであるなら、ノンレム睡眠の脳波の役割は受け取った情報を吟味することだ。その吟味の過程で、情報を移動したり、記憶を整理したりしている。\n夢をみているとき、身体はマヒ状態になる 夢を見る段階が始まる数秒前になると、身体は完全に麻痺した状態になりそれが睡眠の終わりまでずっと続く。\nレム睡眠とノンレム睡眠、どちらが重要か？ 進化の過程で最初に出現したのはノンレム睡眠。\n徹夜明けの脳波、レム睡眠よりも、深いノンレム睡眠のほうをはるか求める。\n回復のチャンスがどれだけあろうとも、脳は、一度の睡眠で失われた睡眠のすべてを取り戻そうとしないということだ。ノンレム睡眠とレム睡眠を個別に見て、トータルの睡眠時間を見ても同じ結果になる。\n人間だけでなくすべての種族は、失われた睡眠を一度に取り戻すことはできない。\nレム睡眠こそ最大のギフトだ レム睡眠の間に見る夢には、進化の面でもう1つ大きな貢献をしている。それは、創造性を育てることだ。ノンレム睡眠の役割は、新しい記憶を長期の保管庫に移動させることだった。しかし、それらの新しい記憶を取り出し、それまでの経験のカタログと衝突させるのはレム睡眠の役目だ。\nレム睡眠の間に起こる記憶の衝突から、創造性の火花が生まれる。それまで関連のなかった情報の間に、新しいつながりがつくられるからだ。睡眠サイクルをくり返しながら、レム睡眠は脳内に広大な情報のネットワークをつくっていく。\nまた、レム睡眠は一歩引いて視野を広げ、答えのようなものを導き出すこともできる。つまり、バラバラの情報を個別に理解するだけでなく、情報全体が意味することも理解できるのだ。そして目を覚ますと、昨日までの難問の解決策が見つかり、革新的なアイデアが思いついたりするのである。\n自閉症スペクトラムとレム睡眠 1990年代、生まれたばかりのラットの研究が始まった。彼らのレム睡眠を阻害したところ、神経の屋根、つまり脳の皮質がつくられなくなった。脳の建設工事そのものが完全に中断してしまったので。どんなに日がたっても、レム睡眠を奪われた脳波、もうそれ以上の発達を見せることがなかった。レム睡眠を復活させると、皮質の建設工事も再開された。しかし建設のペースが上がるわけではなく、脳が完全な発達を遂げることはなかった。生まれたばかりの時期に睡眠を奪われると、脳の発達の遅れは一生残るということだ。\nなぜ睡眠で記憶力が高まるのか？ 睡眠紡錘波の活動を観察しているときに、100ミリ秒から200ミリ秒ごとに一定の感覚で流れる電気の存在に気が付いた。 その電流は、新しい記憶を保管する海馬と、もっと大容量で、長期記憶を保存する部位は脳の皮質に存在する。海馬がUSBメモリーだとするなら、この部位はハードディスクのようなものだ。\nその瞬間、私たちは、睡眠の世界で人知れず行われている電気の活動を目撃していた。新しく入ってきた情報を、一時的な小容量の保存庫（海馬）から、長期的な大容量の保存庫（皮質に）移動していた。 こうして睡眠中に海馬の中がきれいに掃除されるので、起きたときにまた新しい情報を取り入れることができるのだ。\n徹夜は成績を下げる 徹夜グループは睡眠をとったグループに比べ、成績が40%悪かった。深いノンレム睡眠を奪われて浅い眠りになると、たとえ睡眠はとっても海馬の学習能力は低下する。 睡眠不足の脳は、新しい記憶を司るニューロンのつながりを形成することができなくなる。つまり、新しい記憶を脳にしっかり刻みつけることが、ほぼ不可能になるのだ。\n24時間ずっと起きていたラットも、ほんの2時間か3時間の睡眠を奪ったラットも、ほんの2時間か3時間の睡眠を奪っただけのラットも、結果は同じだった。シナプスの中で記憶の土台になるプロテインを形成するのは、学習プロセスの中で記憶の土台になるプロテインを形成するのは、学習プロセスの中でもっとも基本的な作業だが、睡眠不足の脳はそれさえもできなくなってしまう。\nこの分野の最新の研究によると、睡眠不足はDNAにも影響を与える。 という。具体的には、海馬の脳細胞の中にある、学習に関連した遺伝子だ。つまり睡眠不足は、脳内にある記憶をつくる装置に、そこまで深いダメージを与えるということだ。この状態で何かを記憶するのは、波打ち際に砂のお城をつくることに似ている。結果は言わなくてもわかるだろう。\n学習したその日に寝ないと記憶は脳に定着しない 睡眠による記憶の強化はまったく認められなかった。つまり、何かを新しく学習したその日の夜に眠らないと、記憶を刻みつけるチャンスを失ってしまう。その後でどんなにたくさん寝ても、最初の睡眠を取り戻すことはできない。\n睡眠不足と肥満 睡眠が足りないと、満足感を知らせるホルモンであるレプチンの分泌が減り、食欲を刺激するグレリンの分泌が増える。これはまさに、ダブルパンチの精神攻撃だ。睡眠不足という1人の敵が、「満腹感をなくす」というパンチと、「空腹感を増やす」というパンチを同時に放ってくる。その結果、睡眠不足の人は、どんなに食べてきても満足できなくなってしまう。\n夜は涼しく-理想的な寝室の温度は18.3度 眠りに入るには身体の中心の体温（中核温）が摂氏1度ほど下がる必要がある。そのため、暑すぎる部屋よりは、寒すぎる部屋のほうが寝付きがいい。寒すぎる部屋は少なくとも脳と身体の温度を下げて、眠るのに最適な状態にしてくれるからだ。\n中核温が低下すると、脳の中央にある温度に敏感な細胞がその細胞がその変化を感知する。この細胞は視床下部の中にある。温度の細胞のすぐ隣にあるのが、脳内の24時間時計である視交叉上核だ。もちろん、それには理由がる。夜になり、中核温がある一定の温度より下がると、温度の細胞がすぐ隣にいる視交叉上核にメモを送る。そのメモと、あたりが暗くなってきたという情報を頼りに、視交叉上核はメラトニンの分泌を始める。\nつまり、メラトニンの分泌を促す情報は、日が暮れて暗くなることだけではない。日が暮れて温度が下がることも、メラトニンの分泌には必要だ。\n睡眠不足はなぜ損失を与えるのか 実験では、睡眠不足の被験者と、睡眠を十分にとっている被験者を集め、それぞれに自分のやりたいタスクを選んでもらった。タスクの内容は、単純作業（留守番電話を聞く）から頭を使う仕事（問題解決能力と創造性が必要とされる複雑なプロジェクトの遂行）までさまざまだ。そして、**いちばん簡単な仕事を選ぶのは、きまって睡眠不足の被験者だった。**彼らはつねに楽な道を選び、創造的な解決策をほとんど思いつかない。\n興味深いことに、先ほど紹介した実験の参加者たちは、自分が寝不足の時は簡単な仕事を選んでいることも、仕事の効率が落ちていることも自覚していなかった。\n","permalink":"https://hirotoshimizu.github.io/posts/why-we-sleep/","summary":"睡眠こそ最強の解決策である なぜ朝型人間と夜型人間がいるのか 朝型と夜型の分類は、「クロノタイプ」とも呼ばれている。大人の場合、クロノタイプはほぼ遺伝で決まることが多い。\n午後のコーヒーが夜の睡眠を奪う 睡眠と覚醒を決める要素は2つあり、24時間単位の概日リズムはその最初の1つだ。そして2つ目の要素が「睡眠圧」になる。今この瞬間も、あなたの脳内では、「アデノシン」と呼ばれる化学物質が着々と増えている。アデノシンの増加は、起きている間ずっと続いている。だから起きている時間が長くなるほど、脳内のアデノシンも多くなるということだ。アデノシンは、起きている時間を計測する装置だという考え方もできる。\n脳内のアデノシンが増えると、眠りたいという欲求が高まる。この現象が「睡眠圧」だ。脳内に蓄積されたアデノシンは、脳の覚醒を司る部位のボリュームを下げ、睡眠を司る部分のボリュームをあげるという、2つの技を同時にこなすことができる。アデノシンの量がピークに達すると、もう眠くて眠くてたまらないという状態だ。たいていの人は、12時間から16時間起きているとこの状態になる。\nしかし、ある種の化学物質を使えば、アデノシンから出る睡眠信号を消し、眠気を覚ますことができる。その物質が「カフェイン」だ。\nカフェインの半減期は、平均して5時間から7時間になる。たとえば午後7時30頃に夕食のコーヒーを1杯飲んだとすると、午前1時30分になってもまだ半分のカフェインが体内に残っていることになる。\nなぜ深い眠りと浅い眠りがあるのか 深いノンレム睡眠のいちばん大切な機能は、もういらなくなったニューロンのつながりを削除することだ。対照的に夢を見るレム睡眠は、ニューロンのつながりを強化する役割をはたしている。\n2つの睡眠で記憶スペースの容量不足を解消する 粘土を使って像を造ると想像してみよう。まず、大きな粘土のかたまりを台座に置く。大きな粘土のかたまりは、寝るまでに脳内に蓄積されたすべの記憶にあたる。次に、粘土のかたまりを削り、大まかな形にしていく。これが長時間続くノンレム睡眠だ。その間に、細部の造形を行うこともある（短いレム睡眠）。\nこの最初の段階が終わると、また粘土を大まかに削る作業が始まる（2度目の長いノンレム睡眠）、それからさらに細部をつくり込んでいく（先ほどより少し長いレム睡眠）。このサイクルを何度か繰り返すと、求められる作業のバランスが変わる。大まかに削る作業はほぼ終わり、今度は細部のつくり込みがメインになる（レム睡眠が大半を占め、ノンレム睡眠の出番はほとんどなくなる）。\nこのように、睡眠は巧みな技を使って、記憶スペースの容量不足という問題を解決している。\nノンレム睡眠で情報を整理し、レム睡眠で情報を統合する 深い眠りのゆっくりした脳波が、短期の記憶が保管されている場所から新しい記憶の入った荷物を受け取り、長期の記憶を保管する場所に届けている。\n覚醒時の脳波の役割が、外側の情報を受け取ることであるなら、ノンレム睡眠の脳波の役割は受け取った情報を吟味することだ。その吟味の過程で、情報を移動したり、記憶を整理したりしている。\n夢をみているとき、身体はマヒ状態になる 夢を見る段階が始まる数秒前になると、身体は完全に麻痺した状態になりそれが睡眠の終わりまでずっと続く。\nレム睡眠とノンレム睡眠、どちらが重要か？ 進化の過程で最初に出現したのはノンレム睡眠。\n徹夜明けの脳波、レム睡眠よりも、深いノンレム睡眠のほうをはるか求める。\n回復のチャンスがどれだけあろうとも、脳は、一度の睡眠で失われた睡眠のすべてを取り戻そうとしないということだ。ノンレム睡眠とレム睡眠を個別に見て、トータルの睡眠時間を見ても同じ結果になる。\n人間だけでなくすべての種族は、失われた睡眠を一度に取り戻すことはできない。\nレム睡眠こそ最大のギフトだ レム睡眠の間に見る夢には、進化の面でもう1つ大きな貢献をしている。それは、創造性を育てることだ。ノンレム睡眠の役割は、新しい記憶を長期の保管庫に移動させることだった。しかし、それらの新しい記憶を取り出し、それまでの経験のカタログと衝突させるのはレム睡眠の役目だ。\nレム睡眠の間に起こる記憶の衝突から、創造性の火花が生まれる。それまで関連のなかった情報の間に、新しいつながりがつくられるからだ。睡眠サイクルをくり返しながら、レム睡眠は脳内に広大な情報のネットワークをつくっていく。\nまた、レム睡眠は一歩引いて視野を広げ、答えのようなものを導き出すこともできる。つまり、バラバラの情報を個別に理解するだけでなく、情報全体が意味することも理解できるのだ。そして目を覚ますと、昨日までの難問の解決策が見つかり、革新的なアイデアが思いついたりするのである。\n自閉症スペクトラムとレム睡眠 1990年代、生まれたばかりのラットの研究が始まった。彼らのレム睡眠を阻害したところ、神経の屋根、つまり脳の皮質がつくられなくなった。脳の建設工事そのものが完全に中断してしまったので。どんなに日がたっても、レム睡眠を奪われた脳波、もうそれ以上の発達を見せることがなかった。レム睡眠を復活させると、皮質の建設工事も再開された。しかし建設のペースが上がるわけではなく、脳が完全な発達を遂げることはなかった。生まれたばかりの時期に睡眠を奪われると、脳の発達の遅れは一生残るということだ。\nなぜ睡眠で記憶力が高まるのか？ 睡眠紡錘波の活動を観察しているときに、100ミリ秒から200ミリ秒ごとに一定の感覚で流れる電気の存在に気が付いた。 その電流は、新しい記憶を保管する海馬と、もっと大容量で、長期記憶を保存する部位は脳の皮質に存在する。海馬がUSBメモリーだとするなら、この部位はハードディスクのようなものだ。\nその瞬間、私たちは、睡眠の世界で人知れず行われている電気の活動を目撃していた。新しく入ってきた情報を、一時的な小容量の保存庫（海馬）から、長期的な大容量の保存庫（皮質に）移動していた。 こうして睡眠中に海馬の中がきれいに掃除されるので、起きたときにまた新しい情報を取り入れることができるのだ。\n徹夜は成績を下げる 徹夜グループは睡眠をとったグループに比べ、成績が40%悪かった。深いノンレム睡眠を奪われて浅い眠りになると、たとえ睡眠はとっても海馬の学習能力は低下する。 睡眠不足の脳は、新しい記憶を司るニューロンのつながりを形成することができなくなる。つまり、新しい記憶を脳にしっかり刻みつけることが、ほぼ不可能になるのだ。\n24時間ずっと起きていたラットも、ほんの2時間か3時間の睡眠を奪ったラットも、ほんの2時間か3時間の睡眠を奪っただけのラットも、結果は同じだった。シナプスの中で記憶の土台になるプロテインを形成するのは、学習プロセスの中で記憶の土台になるプロテインを形成するのは、学習プロセスの中でもっとも基本的な作業だが、睡眠不足の脳はそれさえもできなくなってしまう。\nこの分野の最新の研究によると、睡眠不足はDNAにも影響を与える。 という。具体的には、海馬の脳細胞の中にある、学習に関連した遺伝子だ。つまり睡眠不足は、脳内にある記憶をつくる装置に、そこまで深いダメージを与えるということだ。この状態で何かを記憶するのは、波打ち際に砂のお城をつくることに似ている。結果は言わなくてもわかるだろう。\n学習したその日に寝ないと記憶は脳に定着しない 睡眠による記憶の強化はまったく認められなかった。つまり、何かを新しく学習したその日の夜に眠らないと、記憶を刻みつけるチャンスを失ってしまう。その後でどんなにたくさん寝ても、最初の睡眠を取り戻すことはできない。\n睡眠不足と肥満 睡眠が足りないと、満足感を知らせるホルモンであるレプチンの分泌が減り、食欲を刺激するグレリンの分泌が増える。これはまさに、ダブルパンチの精神攻撃だ。睡眠不足という1人の敵が、「満腹感をなくす」というパンチと、「空腹感を増やす」というパンチを同時に放ってくる。その結果、睡眠不足の人は、どんなに食べてきても満足できなくなってしまう。\n夜は涼しく-理想的な寝室の温度は18.3度 眠りに入るには身体の中心の体温（中核温）が摂氏1度ほど下がる必要がある。そのため、暑すぎる部屋よりは、寒すぎる部屋のほうが寝付きがいい。寒すぎる部屋は少なくとも脳と身体の温度を下げて、眠るのに最適な状態にしてくれるからだ。\n中核温が低下すると、脳の中央にある温度に敏感な細胞がその細胞がその変化を感知する。この細胞は視床下部の中にある。温度の細胞のすぐ隣にあるのが、脳内の24時間時計である視交叉上核だ。もちろん、それには理由がる。夜になり、中核温がある一定の温度より下がると、温度の細胞がすぐ隣にいる視交叉上核にメモを送る。そのメモと、あたりが暗くなってきたという情報を頼りに、視交叉上核はメラトニンの分泌を始める。\nつまり、メラトニンの分泌を促す情報は、日が暮れて暗くなることだけではない。日が暮れて温度が下がることも、メラトニンの分泌には必要だ。\n睡眠不足はなぜ損失を与えるのか 実験では、睡眠不足の被験者と、睡眠を十分にとっている被験者を集め、それぞれに自分のやりたいタスクを選んでもらった。タスクの内容は、単純作業（留守番電話を聞く）から頭を使う仕事（問題解決能力と創造性が必要とされる複雑なプロジェクトの遂行）までさまざまだ。そして、**いちばん簡単な仕事を選ぶのは、きまって睡眠不足の被験者だった。**彼らはつねに楽な道を選び、創造的な解決策をほとんど思いつかない。\n興味深いことに、先ほど紹介した実験の参加者たちは、自分が寝不足の時は簡単な仕事を選んでいることも、仕事の効率が落ちていることも自覚していなかった。","title":"Why We Sleep"},{"content":"ソースコードの依存関係が（具象ではなく）抽象だけを参照しているシステムが最も柔軟である。\nBefore from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class Authorizer(ABC): @abstractmethod def is_authorized(self) -\u0026gt; bool: pass class Authorizer_SMS(Authorizer): def __init__(self): self.authorized = False def verify_code(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.authorized = True def is_authorized(self) -\u0026gt; bool: return self.authorized class Authorizer_Google(Authorizer): def __init__(self): self.authorized = False def verify_code(self, code): print(f\u0026#39;Verifying Google auth code {code}\u0026#39;) self.authorized = True def is_authorized(self) -\u0026gt; bool: return self.authorized class Authorizer_Robot(Authorizer): def __init__(self): self.authorized = False def not_a_robot(self): self.authorized = True def is_authorized(self) -\u0026gt; bool: return self.authorized class PaymentProcessor(ABC): @abstractmethod def pay(self, order): pass class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code, authorizer: Authorizer): self.security_code = security_code self.authorizer = authorizer def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code def pay(self, order): print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class PaypalPaymentProcessor(PaymentProcessor): def __init__(self, email_address, authorizer: Authorizer): self.email_address = email_address self.authorizer = authorizer def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing paypal payment type\u0026#39;) print(f\u0026#39;Using email address: {self.email_address}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) authorizer = Authorizer_Robot() # authorizer.verify_code(465839) authorizer.not_a_robot() processor = PaypalPaymentProcessor(\u0026#39;hi@arjancodes.com\u0026#39;, authorizer) processor.pay(order) After from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class Authorizer(ABC): @abstractmethod def is_authorized(self) -\u0026gt; bool: pass class SMSAuth(Authorizer): authorized = False def verify_code(self, code): print(f\u0026#39;Verifying code {code}\u0026#39;) self.authorized = True def is_authorized(self) -\u0026gt; bool: return self.authorized class NotARobot(Authorizer): authorized = False def not_a_robot(self): print(f\u0026#39;Are you a robot? Nope.\u0026#39;) self.authorized = True def is_authorized(self) -\u0026gt; bool: return self.authorized class PaymentProcessor(ABC): @abstractmethod def pay(self, order): pass class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code, authorizer: Authorizer): self.authorizer = authorizer self.security_code = security_code def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code def pay(self, order): print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class PaypalPaymentProcessor(PaymentProcessor): def __init__(self, email_address, authorizer: Authorizer): self.authorizer = authorizer self.email_address = email_address def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing paypal payment type\u0026#39;) print(f\u0026#39;Using email address: {self.email_address}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) authorizer = NotARobot() processor = DebitPaymentProcessor(\u0026#39;2349875\u0026#39;, authorizer) authorizer.not_a_robot() processor.pay(order) ","permalink":"https://hirotoshimizu.github.io/posts/dependency-inversion-principle/","summary":"ソースコードの依存関係が（具象ではなく）抽象だけを参照しているシステムが最も柔軟である。\nBefore from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class Authorizer(ABC): @abstractmethod def is_authorized(self) -\u0026gt; bool: pass class Authorizer_SMS(Authorizer): def __init__(self): self.authorized = False def verify_code(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.authorized = True def is_authorized(self) -\u0026gt; bool: return self.","title":"Dependency Inversion Principle"},{"content":"包括的なインターフェースがあるより、いくつかの特定のインターフェースに分割すべき。\nBefore from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def auth_sms(self, code): pass @abstractmethod def pay(self, order): pass class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code self.verified = False def auth_sms(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.verified = True def pay(self, order): if not self.verified: raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code def auth_sms(self, code): raise Exception(\u0026#39;Credit card payments don\u0026#39;t support SMS code authorization.\u0026#39;) def pay(self, order): print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class PaypalPaymentProcessor(PaymentProcessor): def __init__(self, email_address): self.email_address = email_address self.verified = False def auth_sms(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.verified = True def pay(self, order): if not self.verified: raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing paypal payment type\u0026#39;) print(f\u0026#39;Using email address: {self.email_address}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) processor = DebitPaymentProcessor(\u0026#39;2349875\u0026#39;) processor.auth_sms(465839) processor.pay(order) Before from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def auth_sms(self, code): pass @abstractmethod def pay(self, order): pass class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code self.verified = False def auth_sms(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.verified = True def pay(self, order): if not self.verified: raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code def auth_sms(self, code): raise Exception(\u0026#39;Credit card payments don\u0026#39;t support SMS code authorization.\u0026#39;) def pay(self, order): print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class PaypalPaymentProcessor(PaymentProcessor): def __init__(self, email_address): self.email_address = email_address self.verified = False def auth_sms(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.verified = True def pay(self, order): if not self.verified: raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing paypal payment type\u0026#39;) print(f\u0026#39;Using email address: {self.email_address}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) processor = DebitPaymentProcessor(\u0026#39;2349875\u0026#39;) processor.auth_sms(465839) processor.pay(order) 上記の場合、auth_sms を汎用的な\nPaymentProcessor に設定しているが、\nCreditPaymentProcessor では本来必要ない。\nそのため、PaymentProcessor の\nサブクラス PaymentProcessor_SMS を作成し、PaymentProcessor を継承させる。 DebitPaymentProcessor, PaypalPaymentProcessor は auth_sms が必要なため、 PaymentProcessor_SMS  を継承させる。\nAfter from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def pay(self, order): pass class PaymentProcessor_SMS(PaymentProcessor): @abstractmethod def auth_sms(self, code): pass class DebitPaymentProcessor(PaymentProcessor_SMS): def __init__(self, security_code): self.security_code = security_code self.verified = False def auth_sms(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.verified = True def pay(self, order): if not self.verified: raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code def pay(self, order): print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class PaypalPaymentProcessor(PaymentProcessor_SMS): def __init__(self, email_address): self.email_address = email_address self.verified = False def auth_sms(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.verified = True def pay(self, order): if not self.verified: raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing paypal payment type\u0026#39;) print(f\u0026#39;Using email address: {self.email_address}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) processor = DebitPaymentProcessor(\u0026#39;2349875\u0026#39;) processor.auth_sms(465839) processor.pay(order) Composision from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class SMSAuth: authorized = False def verify_code(self, code): print(f\u0026#39;Verifying code {code}\u0026#39;) self.authorized = True def is_authorized(self) -\u0026gt; bool: return self.authorized class PaymentProcessor(ABC): @abstractmethod def pay(self, order): pass class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code, authorizer: SMSAuth): self.authorizer = authorizer self.security_code = security_code def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code def pay(self, order): print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class PaypalPaymentProcessor(PaymentProcessor): def __init__(self, security_code, authorizer: SMSAuth): self.authorizer = authorizer self.email_address = email_address def pay(self, order): if not self.authorizer.is_authorized(): raise Exception(\u0026#39;Not authorized\u0026#39;) print(\u0026#39;Processing paypal payment type\u0026#39;) print(f\u0026#39;Using email address: {self.email_address}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) authorizer = SMSAuth() processor = DebitPaymentProcessor(\u0026#39;2349875\u0026#39;, authorizer) authorizer.verify_code(465839) processor.pay(order) ","permalink":"https://hirotoshimizu.github.io/posts/interface-segregation-principle/","summary":"包括的なインターフェースがあるより、いくつかの特定のインターフェースに分割すべき。\nBefore from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def auth_sms(self, code): pass @abstractmethod def pay(self, order): pass class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code self.verified = False def auth_sms(self, code): print(f\u0026#39;Verifying SMS code {code}\u0026#39;) self.","title":"Interface Segregation Principle"},{"content":"サブクラスは、スーパークラスと置換可能でなければならない。\nBefore from abc import ABC, abstractmethod class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def pay(self, order: Order, security_code: str) -\u0026gt; None: pass class DebitPaymentProcessor(PaymentProcessor): def pay(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def pay(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) processor = CreditPaymentProcessor() processor.pay(order, \u0026#39;0372846\u0026#39;) PaymentProcessor に PaypalPaymentProcessor を追加したい。\nただし、PaypalPaymentProcessor は security_code の代わりに email_address を使いたい。\nAfter from abc import ABC, abstractmethod class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def pay(self, order: Order) -\u0026gt; None: pass class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code: str) -\u0026gt; None: self.security_code = security_code def pay(self, order: Order) -\u0026gt; None: print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def __init__(self, security_code: str) -\u0026gt; None: self.security_code = security_code def pay(self, order: Order) -\u0026gt; None: print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {self.security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class PaypalPaymentProcessor(PaymentProcessor): def __init__(self, email_address): self.email_address = email_address def pay(self, order: Order) -\u0026gt; None: print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying email address: {self.email_address}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) processor = PaypalPaymentProcessor(\u0026#39;test@test.com\u0026#39;) processor.pay(order) ","permalink":"https://hirotoshimizu.github.io/posts/liskov-substitution-principle/","summary":"サブクラスは、スーパークラスと置換可能でなければならない。\nBefore from abc import ABC, abstractmethod class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def pay(self, order: Order, security_code: str) -\u0026gt; None: pass class DebitPaymentProcessor(PaymentProcessor): def pay(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) order.","title":"Liskov Substitution Principle"},{"content":"ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければならない。\nソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべき。\nBefore class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#34;open\u0026#34; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor: def pay_debit(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#34;Processing debit payment type\u0026#34;) print(f\u0026#34;Verifying security code: {security_code}\u0026#34;) order.status = \u0026#34;paid\u0026#34; def pay_credit(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#34;Processing credit payment type\u0026#34;) print(f\u0026#34;Verifying security code: {security_code}\u0026#34;) order.status = \u0026#34;paid\u0026#34; order = Order() order.add_item(\u0026#34;Keyboard\u0026#34;, 1, 50) order.add_item(\u0026#34;SSD\u0026#34;, 1, 150) order.add_item(\u0026#34;USB cable\u0026#34;, 2, 5) print(order.total_price()) processor = PaymentProcessor() processor.pay_debit(order, \u0026#34;0372846\u0026#34;) After from abc import ABC, abstractmethod class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#34;open\u0026#34; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def pay(self, order: Order, security_code: str) -\u0026gt; None: pass class DebitPaymentProcessor(PaymentProcessor): def pay(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; class CreditPaymentProcessor(PaymentProcessor): def pay(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#34;Verifying security code: {security_code}\u0026#34;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#34;Keyboard\u0026#34;, 1, 50) order.add_item(\u0026#34;SSD\u0026#34;, 1, 150) order.add_item(\u0026#34;USB cable\u0026#34;, 2, 5) print(order.total_price()) processor = CreditPaymentProcessor() processor.pay(order, \u0026#34;0372846\u0026#34;) ","permalink":"https://hirotoshimizu.github.io/posts/open-closed-principle/","summary":"ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければならない。\nソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべき。\nBefore class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#34;open\u0026#34; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor: def pay_debit(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#34;Processing debit payment type\u0026#34;) print(f\u0026#34;Verifying security code: {security_code}\u0026#34;) order.","title":"Open Closed Principle"},{"content":"個々のモジュールを変更する理由がたったひとつだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会的構造に大きな影響を受けるようにする。\nモジュールはたったひとつのアクターに対して責務を負うべきである。\nBefore class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total def pay(self, payment_type: str, security_code: str) -\u0026gt; None: if payment_type == \u0026#39;debit\u0026#39;: print(\u0026#39;Proccessing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) self.status = \u0026#39;paid\u0026#39; elif payment_type == \u0026#39;credit\u0026#39;: print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) self.status = \u0026#39;paid\u0026#39; else: raise Exception(f\u0026#39;Unknown payment type: {payment_type}\u0026#39;) order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) order.pay(\u0026#39;debit\u0026#39;, \u0026#39;0372846\u0026#39;) After class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor: def pay_debit(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#39;Processing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; def pay_credit(self, order: Order, security_code: str) -\u0026gt; None: print(\u0026#39;Processing credit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) order.status = \u0026#39;paid\u0026#39; order = Order() order.add_item(\u0026#39;Keyboard\u0026#39;, 1, 50) order.add_item(\u0026#39;SSD\u0026#39;, 1, 150) order.add_item(\u0026#39;USB cable\u0026#39;, 2, 5) print(order.total_price()) processor = PaymentProcessor() processor.pay_debit(order, \u0026#39;0372846\u0026#39;) ","permalink":"https://hirotoshimizu.github.io/posts/single-responsibility-principle/","summary":"個々のモジュールを変更する理由がたったひとつだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会的構造に大きな影響を受けるようにする。\nモジュールはたったひとつのアクターに対して責務を負うべきである。\nBefore class Order: def __init__(self) -\u0026gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = \u0026#39;open\u0026#39; def add_item(self, name: str, quantity: int, price: int) -\u0026gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -\u0026gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total def pay(self, payment_type: str, security_code: str) -\u0026gt; None: if payment_type == \u0026#39;debit\u0026#39;: print(\u0026#39;Proccessing debit payment type\u0026#39;) print(f\u0026#39;Verifying security code: {security_code}\u0026#39;) self.","title":"Single Responsibility Principle"},{"content":"よくできたソフトウェアシステムは、クリーンなコードを書くことから始まる。レンガの出来が悪ければ、その建築は優れたものにはならない。一方、たとえよくできたレンガを使っても、ぐちゃぐちゃなもの作ってしまうことがあり得る。そこで登場するのが「SOLID」原則。\nSOLID原則は、関数やデータ構造をどのようにクラスに組み込むのか、そしてクラスの相互接続をどのようにするのかといったことを教えてくれる。　SOLID原則の目的は、以下のような性質を持つ中間レベルのソフトウェア構造を作ること。\n 変更につよいこと 理解しやすいこと コンポーネントの基盤として、多くのソフトウェアシステムで利用できること  Single Responsibility Principle 個々のモジュールを変更する理由がたったひとつだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会的構造に大きな影響を受けるようにする。\nモジュールはたったひとつのアクターに対して責務を負うべきである。\nOpne Closed Principle ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければならない。\nソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべき。\nLiskov Substitution Principle サブクラスは、スーパークラスと置換可能でなければならない。\nInterface Segregation Principle 包括的なインターフェースがあるより、いくつかの特定のインターフェースに分割すべき。\nDependency Inversion Principle ソースコードの依存関係が（具象ではなく）抽象だけを参照しているシステムが最も柔軟である。\n","permalink":"https://hirotoshimizu.github.io/posts/solid/","summary":"よくできたソフトウェアシステムは、クリーンなコードを書くことから始まる。レンガの出来が悪ければ、その建築は優れたものにはならない。一方、たとえよくできたレンガを使っても、ぐちゃぐちゃなもの作ってしまうことがあり得る。そこで登場するのが「SOLID」原則。\nSOLID原則は、関数やデータ構造をどのようにクラスに組み込むのか、そしてクラスの相互接続をどのようにするのかといったことを教えてくれる。　SOLID原則の目的は、以下のような性質を持つ中間レベルのソフトウェア構造を作ること。\n 変更につよいこと 理解しやすいこと コンポーネントの基盤として、多くのソフトウェアシステムで利用できること  Single Responsibility Principle 個々のモジュールを変更する理由がたったひとつだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会的構造に大きな影響を受けるようにする。\nモジュールはたったひとつのアクターに対して責務を負うべきである。\nOpne Closed Principle ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければならない。\nソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべき。\nLiskov Substitution Principle サブクラスは、スーパークラスと置換可能でなければならない。\nInterface Segregation Principle 包括的なインターフェースがあるより、いくつかの特定のインターフェースに分割すべき。\nDependency Inversion Principle ソースコードの依存関係が（具象ではなく）抽象だけを参照しているシステムが最も柔軟である。","title":"Solid"},{"content":"動機 「関数の抽出」はきわめて頻繁に行われるリファクタリング。\nいつ独立した関数として取り出すかというは「2回以上使われるコードはそれ自体を関数にすべき」のように、再利用に基づいている。\nしかし、最も納得できるのは意図と実装の分離です。何をしているか調べなければわからないコードの断片があるとしたら、「何」をしているかを示す名前の関数として抽出すべきです。そうすれば関数を読み返すだけで関数の目的がすぐに伝わってきます。\n手順  新たな関数を作り、その意図に沿って命名する（どうやるかではなく、何をするかによって名づける。） 抽出したいコードを、元の関数から新たな関数にコピーする。 抽出したコードを調べて、元の関数ではスコープ内だったが抽出後の関数ではスコープ外になった変数を特定する。それらをパラメータとして渡す。 全ての変数を処置したらコンパイルする。 元の関数に残った抽出前のコードを、抽出された関数への呼び出しに置き換える。 テストする。 残りのコードを見て、抽出したコードと同じまたは類似したコードを探し、「関数呼び出しによるインラインコードの置き換え」を適用し、新しい関数を呼ぶ形にできないか検討する。  Before from enum import Enum class Category(Enum): A = 1 B = 2 C = 3 def calculate_tax(category: Category, income: int) -\u0026gt; int: if category == Category.A: discount = 10 elif category == Category.B: discount = 5 else: discount = 0 return income * (100 - discount) // 100 After from enum import Enum class Category(Enum): A = 1 B = 2 C = 3 def calculate_tax(category: Category, income: int) -\u0026gt; int: discount = calc_discount(category) return income * (100 - discount) // 100 def calc_discount(category: Category) -\u0026gt; int: if category == Category.A: discount = 10 elif category == Category.B: discount = 5 else: discount = 0 return discount ","permalink":"https://hirotoshimizu.github.io/posts/extract-function/","summary":"動機 「関数の抽出」はきわめて頻繁に行われるリファクタリング。\nいつ独立した関数として取り出すかというは「2回以上使われるコードはそれ自体を関数にすべき」のように、再利用に基づいている。\nしかし、最も納得できるのは意図と実装の分離です。何をしているか調べなければわからないコードの断片があるとしたら、「何」をしているかを示す名前の関数として抽出すべきです。そうすれば関数を読み返すだけで関数の目的がすぐに伝わってきます。\n手順  新たな関数を作り、その意図に沿って命名する（どうやるかではなく、何をするかによって名づける。） 抽出したいコードを、元の関数から新たな関数にコピーする。 抽出したコードを調べて、元の関数ではスコープ内だったが抽出後の関数ではスコープ外になった変数を特定する。それらをパラメータとして渡す。 全ての変数を処置したらコンパイルする。 元の関数に残った抽出前のコードを、抽出された関数への呼び出しに置き換える。 テストする。 残りのコードを見て、抽出したコードと同じまたは類似したコードを探し、「関数呼び出しによるインラインコードの置き換え」を適用し、新しい関数を呼ぶ形にできないか検討する。  Before from enum import Enum class Category(Enum): A = 1 B = 2 C = 3 def calculate_tax(category: Category, income: int) -\u0026gt; int: if category == Category.A: discount = 10 elif category == Category.B: discount = 5 else: discount = 0 return income * (100 - discount) // 100 After from enum import Enum class Category(Enum): A = 1 B = 2 C = 3 def calculate_tax(category: Category, income: int) -\u0026gt; int: discount = calc_discount(category) return income * (100 - discount) // 100 def calc_discount(category: Category) -\u0026gt; int: if category == Category.","title":"Extract Function"},{"content":"意味のある名前  意図が明確な名前にする 意味のある対比を行う 発音可能な名前を使用する 検索可能な名前を用いる マジックナンバーは定数に メンタルマッピングを避ける 抽象レベルに適切な名前を選ぶ 広いスコープには長い名前を エンコーディングを避ける 名前で副作用を示すべき  関数  小さいこと！ 1つのことを行う 内容をよく表す名前を使う 引数は少なく フラグ引数は使わず、メソッドを分割する 副作用をさける try/catchブロックの分離 DRY(Don\u0026rsquo;t Repeat Yourself) 死んだ関数は削除すべき  コメント 「ダメなコードをコメントで取り繕ってはいけない。書き直すのだ」\n コメントで、ダメなコードを取り繕うことはできない 自分自身をコードで説明する 意図の説明 結果に対する警告  書式化  縦方向の書式化 垂直概念分離性 垂直密度 垂直距離 水平分離性と密度  テスト  1つのテストに1つのアサート 1つのテストでは1つの概念を扱う カバレッジツールを使用する ささいなテストを省略しない 無視することを指定されたテストは、あいまいさへの問いかけである 境界条件テストには注意払う バグの周辺は徹底的にテストを 失敗パターンは何かを語る テストカバレッジパターンは何かを語る テストは高速に実行できるべき  ","permalink":"https://hirotoshimizu.github.io/posts/clean-code/","summary":"意味のある名前  意図が明確な名前にする 意味のある対比を行う 発音可能な名前を使用する 検索可能な名前を用いる マジックナンバーは定数に メンタルマッピングを避ける 抽象レベルに適切な名前を選ぶ 広いスコープには長い名前を エンコーディングを避ける 名前で副作用を示すべき  関数  小さいこと！ 1つのことを行う 内容をよく表す名前を使う 引数は少なく フラグ引数は使わず、メソッドを分割する 副作用をさける try/catchブロックの分離 DRY(Don\u0026rsquo;t Repeat Yourself) 死んだ関数は削除すべき  コメント 「ダメなコードをコメントで取り繕ってはいけない。書き直すのだ」\n コメントで、ダメなコードを取り繕うことはできない 自分自身をコードで説明する 意図の説明 結果に対する警告  書式化  縦方向の書式化 垂直概念分離性 垂直密度 垂直距離 水平分離性と密度  テスト  1つのテストに1つのアサート 1つのテストでは1つの概念を扱う カバレッジツールを使用する ささいなテストを省略しない 無視することを指定されたテストは、あいまいさへの問いかけである 境界条件テストには注意払う バグの周辺は徹底的にテストを 失敗パターンは何かを語る テストカバレッジパターンは何かを語る テストは高速に実行できるべき  ","title":"Clean Code"},{"content":"Bloaters  長い関数(Long Method)\nオブジェクトそのものの受け渡し、関数の抽出、コマンドによる関数の置き換え、問い合わせによる一時変数の置き換え、条件記述の分解、パラメータオブジェクトの導入、ポリモーフィズムによる条件記述の置き換え、ループの分離 巨大なクラス(Large Class)\nクラスの抽出、サブクスによるタイプコードの置き換え、スーパークラスの抽出 データの群れ(Data Clumps)\nオブジェクトそのものの受け渡し、クラスの抽出、パラメータオブジェクトの導入 長いパラメータリスト(Long Parameter List)\nオブジェクトそのものの受け渡し、関数群のクラスへの集約、問い合わせによるパラメータの置き換え、パラメータオブジェクトの導入、フラグパラメータの削除 基本データ型への執着(Primitive Obsession)\nオブジェクトによるプリミティブの置き換え、クラスの抽出、サブクラスによるタイプコードの置き換え、パラメータオブジェクトの導入、ポリモーフィズムによる条件記述の置き換え  Tool Abusers  Switch Statements 相続拒否(Refused Bequest)\n委譲によるサブクラスの置き換え、委譲によるスーパークラスの置き換え、フィールドの押し下げ、メソッドの押し下げ クラスのインターフェース不一致(Alternative Classes w/ Different Interfaces)\n関数宣言の変更、関数の移動、スーパークラスの抽出 一時的属性(Temporary Field)\n関数の移動、クラスの抽出、特殊ケースの導入  Change Preventers  Divergent Change 変更の分散(Shotgun Surgery)\n関数群のクラスへの集約、関数群の変換への集約、関数の移動、関数のインライン化、クラスのインライン化、フィールドの移動、フェーズの分離 Parallel Inheritance Hierarchies  Dispensables  Lazy Class 疑わしき一般化(Speculative Generality)\n関数宣言の変更、関数のインライン化、クラス階層の平坦化、クラスのインライン化、デッドコードの削除 データクラス(Data Class) 重複したコード(Duplicated Code)\n関数の抽出、ステートメントのスライド、メソッドの引き上げ  Couplers  特性の横恋慕(Feature Envy)\n関数の移動、関数の抽出 Inappropriate Intimacy メッセージの連鎖(Message Chains)\n委譲の隠蔽、関数の移動、関数の抽出 仲介人(Middle Man)\n関数のインライン化、仲介人の除去    Coment(コメント)\nアサーションの導入、関数宣言の変更、関数の抽出 Mysterious Name(不可思議な名前)\n関数宣言の変更、フィールド名の変更、変数名の変更 Global Data(グローバルなデータ)\n変数のカプセル化 Mutable Data(変更可能なデータ)\nsetter の削除、関数群のクラスへの集約、関数群の変換への集約、関数の抽出、参照から値への変更、ステートメントのスライド、問い合わせと更新の分離、問い合わせによる導入変数の置き換え、変数のカプセル化、変数の分離 Divergent Change(変更の偏り) Repeated Switches(重複したスイッチ文)\nポリモーフィズムによる条件記述の置き換え Loop(ループ)\nパイプラインによるループの置き換え Lazy Element(怠け者要素)\n関数のインライン化、クラス階層の平坦化、クラスのインライン化 Insider Trading(インサイダー取引)\n委譲によるサブクラスの置き換え、委譲によるスーパークラスの置き換え、委譲の隠匿、関数の移動、フィールドの移動  ","permalink":"https://hirotoshimizu.github.io/posts/code-smells/","summary":"Bloaters  長い関数(Long Method)\nオブジェクトそのものの受け渡し、関数の抽出、コマンドによる関数の置き換え、問い合わせによる一時変数の置き換え、条件記述の分解、パラメータオブジェクトの導入、ポリモーフィズムによる条件記述の置き換え、ループの分離 巨大なクラス(Large Class)\nクラスの抽出、サブクスによるタイプコードの置き換え、スーパークラスの抽出 データの群れ(Data Clumps)\nオブジェクトそのものの受け渡し、クラスの抽出、パラメータオブジェクトの導入 長いパラメータリスト(Long Parameter List)\nオブジェクトそのものの受け渡し、関数群のクラスへの集約、問い合わせによるパラメータの置き換え、パラメータオブジェクトの導入、フラグパラメータの削除 基本データ型への執着(Primitive Obsession)\nオブジェクトによるプリミティブの置き換え、クラスの抽出、サブクラスによるタイプコードの置き換え、パラメータオブジェクトの導入、ポリモーフィズムによる条件記述の置き換え  Tool Abusers  Switch Statements 相続拒否(Refused Bequest)\n委譲によるサブクラスの置き換え、委譲によるスーパークラスの置き換え、フィールドの押し下げ、メソッドの押し下げ クラスのインターフェース不一致(Alternative Classes w/ Different Interfaces)\n関数宣言の変更、関数の移動、スーパークラスの抽出 一時的属性(Temporary Field)\n関数の移動、クラスの抽出、特殊ケースの導入  Change Preventers  Divergent Change 変更の分散(Shotgun Surgery)\n関数群のクラスへの集約、関数群の変換への集約、関数の移動、関数のインライン化、クラスのインライン化、フィールドの移動、フェーズの分離 Parallel Inheritance Hierarchies  Dispensables  Lazy Class 疑わしき一般化(Speculative Generality)\n関数宣言の変更、関数のインライン化、クラス階層の平坦化、クラスのインライン化、デッドコードの削除 データクラス(Data Class) 重複したコード(Duplicated Code)\n関数の抽出、ステートメントのスライド、メソッドの引き上げ  Couplers  特性の横恋慕(Feature Envy)\n関数の移動、関数の抽出 Inappropriate Intimacy メッセージの連鎖(Message Chains)","title":"Code Smells"},{"content":"https://leetcode.com/problems/longest-palindromic-substring/\nclass Solution: def longestPalindrome(self, s: str) -\u0026gt; str: res = \u0026#39;\u0026#39; for i in range(len(s)): # odd case tmp = self.helper(s, i, i) if len(tmp) \u0026gt; len(res): res = tmp # even tmp = self.helper(s, i, i+1) if len(tmp) \u0026gt; len(res): res = tmp return res def helper(self, s, l, r): while l \u0026gt;= 0 and r \u0026lt; len(s) and s[l] == s[r]: l -= 1 r += 1 return s[l+1:r] ","permalink":"https://hirotoshimizu.github.io/posts/longest-palindromic-substring/","summary":"https://leetcode.com/problems/longest-palindromic-substring/\nclass Solution: def longestPalindrome(self, s: str) -\u0026gt; str: res = \u0026#39;\u0026#39; for i in range(len(s)): # odd case tmp = self.helper(s, i, i) if len(tmp) \u0026gt; len(res): res = tmp # even tmp = self.helper(s, i, i+1) if len(tmp) \u0026gt; len(res): res = tmp return res def helper(self, s, l, r): while l \u0026gt;= 0 and r \u0026lt; len(s) and s[l] == s[r]: l -= 1 r += 1 return s[l+1:r] ","title":"Longest Palindromic Substring"},{"content":"https://leetcode.com/problems/longest-increasing-subsequence/\nLIS はどんな場合でも最低1になるので、 1を入れた、list を作る。\nreverse order でループし、 ネストしたループで最初にループしている i 以降の数と比較する。\nnums[i] と nums[j] で nums[i] が小さい場合、 subsequence となるので、 LIS[i] に max(LIS[i], 1 + LIS[j]) を入れる。 j は i 以降の数字を見ているので、max()を使わないと LISの最後の 1 で置き換えて 2 となってしまうので注意。\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: LIS = [1] * len(nums) for i in range(len(nums) - 1, -1, -1): for j in range(i + 1, len(nums)): if nums[i] \u0026lt; nums[j]: LIS[i] = max(LIS[i], 1 + LIS[j]) return max(LIS) ","permalink":"https://hirotoshimizu.github.io/posts/longest-increasing-subsequence/","summary":"https://leetcode.com/problems/longest-increasing-subsequence/\nLIS はどんな場合でも最低1になるので、 1を入れた、list を作る。\nreverse order でループし、 ネストしたループで最初にループしている i 以降の数と比較する。\nnums[i] と nums[j] で nums[i] が小さい場合、 subsequence となるので、 LIS[i] に max(LIS[i], 1 + LIS[j]) を入れる。 j は i 以降の数字を見ているので、max()を使わないと LISの最後の 1 で置き換えて 2 となってしまうので注意。\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: LIS = [1] * len(nums) for i in range(len(nums) - 1, -1, -1): for j in range(i + 1, len(nums)): if nums[i] \u0026lt; nums[j]: LIS[i] = max(LIS[i], 1 + LIS[j]) return max(LIS) ","title":"Longest Increasing Subsequence"},{"content":"https://leetcode.com/problems/longest-common-subsequence/\n2d grid を作る。 row, col にそれぞれ、1行、1列追加して 0 を入れる。\ngrid の右下からループし、 縦横が同じ文字でマッチしたら、斜め左上に進む。 その際に1を足す。\nマッチしなかったら、右横か下のどちらか大きい数字を入れる。\nループが終わりgrid[0][0] の箇所に 1番長い subsequence の数が入る。\nclass Solution: def longestCommonSubsequence(self, text1: str, text2: str) -\u0026gt; int: dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)] for i in range(len(text1) - 1, -1, -1): for j in range(len(text2) - 1, -1, -1): if text1[i] == text2[j]: dp[i][j] = 1 + dp[i + 1][j + 1] else: dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]) return dp[0][0] ","permalink":"https://hirotoshimizu.github.io/posts/longest-common-subsequence/","summary":"https://leetcode.com/problems/longest-common-subsequence/\n2d grid を作る。 row, col にそれぞれ、1行、1列追加して 0 を入れる。\ngrid の右下からループし、 縦横が同じ文字でマッチしたら、斜め左上に進む。 その際に1を足す。\nマッチしなかったら、右横か下のどちらか大きい数字を入れる。\nループが終わりgrid[0][0] の箇所に 1番長い subsequence の数が入る。\nclass Solution: def longestCommonSubsequence(self, text1: str, text2: str) -\u0026gt; int: dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)] for i in range(len(text1) - 1, -1, -1): for j in range(len(text2) - 1, -1, -1): if text1[i] == text2[j]: dp[i][j] = 1 + dp[i + 1][j + 1] else: dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]) return dp[0][0] ","title":"Longest Common Subsequence"},{"content":" F / \\ B G / \\ \\ A D I / \\ / C E H  Pre-order Traversal root left subtree right subtree\nF B A D C E G I H\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/\nIterative approach\nclass Solution(object): def preorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; res, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: res.append(node.val) else: stack.append((node.right, False)) stack.append((node.left, False)) stack.append((node, True)) return res Recursive solution\nclass Solution: def preorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: if root is None: return [] return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right) In-order Traversal left subtree root right subtree\nA B C D E F G H I\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/\nIterative approach\nclass Solution(object): def inorderTraversal(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; res, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: res.append(node.val) else: stack.append((node.right, False)) stack.append((node, True)) stack.append((node.left, False)) return res Recursive solution\nPost-order Traversal left subtree right subtree root\nA C E D B H I G F\nIterative approach\nclass Solution(object): def inorderTraversal(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; res, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: res.append(node.val) else: stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return res Recursive solution\n","permalink":"https://hirotoshimizu.github.io/posts/traverse-a-tree/","summary":"F / \\ B G / \\ \\ A D I / \\ / C E H  Pre-order Traversal root left subtree right subtree\nF B A D C E G I H\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/\nIterative approach\nclass Solution(object): def preorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; res, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: res.append(node.val) else: stack.","title":"Traverse a Tree"},{"content":"https://leetcode.com/problems/search-insert-position/\nalgorithm の runtime は O(log n) である必要があるため、 binary search で target の数の位置を調べる。\n変数 left に 0、 right に len(nums) - 1 を設定する。\n(left + right) // 2 で真ん中の値が取得出来るので、 真ん中の位置を mid とする。\nnums の mid の値が target なら、mid の index の値を返す。 もし、target の値が mid より大きい場合、 left を mid + 1 にする。 target の値が mid より小さい場合、 right を mid - 1 にする。\n[1, 3, 5, 6] で target = 2 の場合、\n[1, 3, 5, 6] l m r\ntargetの2 は nums[mid]より小さいので、 r の位置が、 mid - 1 のため、一番左になる。 [1, 3, 5, 6] l m r\n次のループで mid の位置が(0 + 0) // 2 で 0 になる。 target が nums[mid] より大きいので、 left の位置を +1 して右にずらす。 [1, 3, 5, 6] r l m\nleft が right の場所を超えたので、 この時点でループを抜け、left を return する。\nclass Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: left, right = 0, len(nums) - 1 while left \u0026lt;= right: mid = (left + right) // 2 if target == nums[mid]: return mid if target \u0026gt; nums[mid]: left = mid + 1 else: right = mid - 1 return left ","permalink":"https://hirotoshimizu.github.io/posts/search-insert-position/","summary":"https://leetcode.com/problems/search-insert-position/\nalgorithm の runtime は O(log n) である必要があるため、 binary search で target の数の位置を調べる。\n変数 left に 0、 right に len(nums) - 1 を設定する。\n(left + right) // 2 で真ん中の値が取得出来るので、 真ん中の位置を mid とする。\nnums の mid の値が target なら、mid の index の値を返す。 もし、target の値が mid より大きい場合、 left を mid + 1 にする。 target の値が mid より小さい場合、 right を mid - 1 にする。\n[1, 3, 5, 6] で target = 2 の場合、","title":"Search Insert Position"},{"content":"nums = [0,0,1,1,1,2,2,3,3,4] の重複をなくすようにするので、下記のようになる。\nnums = [0,1,2,3,4,,,,,_]\npointer を 2つ使う。\n最初の数字は必ずユニークになるので、 left = 1　とする。\nright は for でループさせながら icrement していく。\nnon-decreasing order なので、 right の値と right - 1　を比較して、 違う値なら一番初めに現れるユニークの数字だとわかる。\nそのためその数字を left pointer がある位置に入れる。 その後、 left pointer をicrementする。\n最終的に left pointer の位置がユニークな数の出現回数となるので、 その値を return する。\nclass Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: left = 1 for right in range(1, len(nums)): if nums[right] != nums[right - 1]: nums[left] = nums[right] left += 1 return left ","permalink":"https://hirotoshimizu.github.io/posts/remove-duplicates-from-sorted-array/","summary":"nums = [0,0,1,1,1,2,2,3,3,4] の重複をなくすようにするので、下記のようになる。\nnums = [0,1,2,3,4,,,,,_]\npointer を 2つ使う。\n最初の数字は必ずユニークになるので、 left = 1　とする。\nright は for でループさせながら icrement していく。\nnon-decreasing order なので、 right の値と right - 1　を比較して、 違う値なら一番初めに現れるユニークの数字だとわかる。\nそのためその数字を left pointer がある位置に入れる。 その後、 left pointer をicrementする。\n最終的に left pointer の位置がユニークな数の出現回数となるので、 その値を return する。\nclass Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: left = 1 for right in range(1, len(nums)): if nums[right] != nums[right - 1]: nums[left] = nums[right] left += 1 return left ","title":"Remove Duplicates From Sorted Array"},{"content":"sentinel ノードは Linked List を空にせず、ヘッドレスにしないようにする。\nアルゴリズムは\nsentinel ノードをセットする。\ncurr と prev のポインターを設定する。\ncurr が null でない場合、ループする。\ncurr.val が 削除する値の場合、\nclass Solution: def removeElements(self, head: Optional[ListNode], val: int) -\u0026gt; Optional[ListNode]: sentinel = ListNode(next=head) prev, curr = sentinel, head while curr: if curr.val == val: prev.next = curr.next else: prev = curr curr = curr.next return sentinel.next ","permalink":"https://hirotoshimizu.github.io/posts/remove-linked-list-elements/","summary":"sentinel ノードは Linked List を空にせず、ヘッドレスにしないようにする。\nアルゴリズムは\nsentinel ノードをセットする。\ncurr と prev のポインターを設定する。\ncurr が null でない場合、ループする。\ncurr.val が 削除する値の場合、\nclass Solution: def removeElements(self, head: Optional[ListNode], val: int) -\u0026gt; Optional[ListNode]: sentinel = ListNode(next=head) prev, curr = sentinel, head while curr: if curr.val == val: prev.next = curr.next else: prev = curr curr = curr.next return sentinel.next ","title":"Remove Linked List Elements"},{"content":"https://leetcode.com/problems/path-sum/solution/\nノードがリーフでない場合は、子に対してhasPathSumメソッドを再帰的に呼び出し、合計を現在のノードの値だけ減らす。\nノードがリーフの場合、現在の合計がゼロであるかどうか、つまり最初の合計が検出されたかどうかを確認します。\nBase case は、root が none ということはリーフの下の node を確認してるので、sum が 0 になっていないので False を返す。\nclass Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: if not root: return False targetSum -= root.val if not root.left and not root.right: # if reach a leaf return targetSum == 0 return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum) ","permalink":"https://hirotoshimizu.github.io/posts/path-sum/","summary":"https://leetcode.com/problems/path-sum/solution/\nノードがリーフでない場合は、子に対してhasPathSumメソッドを再帰的に呼び出し、合計を現在のノードの値だけ減らす。\nノードがリーフの場合、現在の合計がゼロであるかどうか、つまり最初の合計が検出されたかどうかを確認します。\nBase case は、root が none ということはリーフの下の node を確認してるので、sum が 0 になっていないので False を返す。\nclass Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: if not root: return False targetSum -= root.val if not root.left and not root.right: # if reach a leaf return targetSum == 0 return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum) ","title":"Path Sum"},{"content":"https://leetcode.com/problems/isomorphic-strings/\ns と t をマッピングして考える。 この際、同じ文字なのに違う文字がマッピングされる場合\nisomorphic にならない。\nex. foo bar\n | f → b | | o → a | | o → r |  | b → f | | a → o | | r → o | o が a と r にマッピングされているので、 isomorphic にならず、false になる。\nclass Solution: def isIsomorphic(self, s: str, t: str) -\u0026gt; bool: mapST, mapTS = {}, {} for c1, c2 in zip(s, t): if((c1 in mapST and mapST[c1] != c2) or (c2 in mapTS and mapTS[c2] != c1)): return False mapST[c1] = c2 mapTS[c2] = c1 return True ","permalink":"https://hirotoshimizu.github.io/posts/isomorphic-strings/","summary":"https://leetcode.com/problems/isomorphic-strings/\ns と t をマッピングして考える。 この際、同じ文字なのに違う文字がマッピングされる場合\nisomorphic にならない。\nex. foo bar\n | f → b | | o → a | | o → r |  | b → f | | a → o | | r → o | o が a と r にマッピングされているので、 isomorphic にならず、false になる。\nclass Solution: def isIsomorphic(self, s: str, t: str) -\u0026gt; bool: mapST, mapTS = {}, {} for c1, c2 in zip(s, t): if((c1 in mapST and mapST[c1] !","title":"Isomorphic Strings"},{"content":"https://leetcode.com/problems/min-stack/solution/\n2つの stack を使う。 1つ目の stack は普通のstackを使うように扱う。(Stack) 2つ目の stack は現在の minimum をトラックするのに使う。(MinStack)\nMinStack の pushメソッドは現在の値が stack の top より小さい場合、 push される。\npopメソッドは Stack のみからpopすると MinStack と合わなくなるので、 If top of main_stack == top of min_tracker_stack: min_tracker_stack.pop() の処理が必要になる。\nclass MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -\u0026gt; None: self.stack.append(x) if not self.min_stack or x \u0026lt;= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -\u0026gt; None: if self.min_stack[-1] == self.stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -\u0026gt; int: return self.stack[-1] def getMin(self) -\u0026gt; int: return self.min_stack[-1] ","permalink":"https://hirotoshimizu.github.io/posts/min-stack/","summary":"https://leetcode.com/problems/min-stack/solution/\n2つの stack を使う。 1つ目の stack は普通のstackを使うように扱う。(Stack) 2つ目の stack は現在の minimum をトラックするのに使う。(MinStack)\nMinStack の pushメソッドは現在の値が stack の top より小さい場合、 push される。\npopメソッドは Stack のみからpopすると MinStack と合わなくなるので、 If top of main_stack == top of min_tracker_stack: min_tracker_stack.pop() の処理が必要になる。\nclass MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -\u0026gt; None: self.stack.append(x) if not self.min_stack or x \u0026lt;= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -\u0026gt; None: if self.min_stack[-1] == self.stack[-1]: self.min_stack.pop() self.","title":"Min Stack"},{"content":"anagram かどうかを調べるには s, t の出現する文字のカウントが同じなら anagram と言える。\n回答方法は\n 文字数をカウントし、s と t を比較する 文字数をカウントし、s と t を比較する(Counter を使う) sorted を使う  Input: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo;\n 文字数をカウントし、s と t を比較する  class Solution: def isAnagram(self, s: str, t: str) -\u0026gt; bool: if len(s)!= len(t): return False count_s, count_t = {}, {} for i in range(len(s)): count_s[s[i]] = 1 + count_s.get(s[i], 0) count_t[t[i]] = 1 + count_t.get(t[i], 0) for c in count_s: if count_s[c] != count_t.get(c, 0): return False return True 文字数をカウントし、s と t を比較する(Counter を使う)  Counter を使うことにより、 {\u0026lsquo;a\u0026rsquo;: 3, \u0026lsquo;n\u0026rsquo;: 1, \u0026lsquo;g\u0026rsquo;: 1, \u0026lsquo;r\u0026rsquo;: 1, \u0026lsquo;m\u0026rsquo;: 1} 出現文字とその回数を取得できる。\nそのため anagram であれば true が返る。\nclass Solution: def isAnagram(self, s: str, t: str) -\u0026gt; bool: return Counter(s) == Counter(t) sorted を使う  sorted を使うことにより、 s, t が [\u0026lsquo;a\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, \u0026lsquo;g\u0026rsquo;, \u0026lsquo;m\u0026rsquo;, \u0026lsquo;n\u0026rsquo;, \u0026lsquo;r\u0026rsquo;] と sort される。\nそのため anagram であれば true が返る。\nclass Solution: def isAnagram(self, s: str, t: str) -\u0026gt; bool: return sorted(s) == sorted(t) ","permalink":"https://hirotoshimizu.github.io/posts/valid-anagram/","summary":"anagram かどうかを調べるには s, t の出現する文字のカウントが同じなら anagram と言える。\n回答方法は\n 文字数をカウントし、s と t を比較する 文字数をカウントし、s と t を比較する(Counter を使う) sorted を使う  Input: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo;\n 文字数をカウントし、s と t を比較する  class Solution: def isAnagram(self, s: str, t: str) -\u0026gt; bool: if len(s)!= len(t): return False count_s, count_t = {}, {} for i in range(len(s)): count_s[s[i]] = 1 + count_s.get(s[i], 0) count_t[t[i]] = 1 + count_t.get(t[i], 0) for c in count_s: if count_s[c] !","title":"Valid Anagram"},{"content":"パターン1 7 → 49 → 97 → 130 → 10 → 1\nパターン2 2 → 4 → 16 → 37 → 30 → 9 → 81 → 65 → 61 → 37\nAlgorithm\n  number n の次の数が何かを調べる\n  cycle に入ったかを調べる。\n  の調べ方 19 → 1^2 + 9^2 = 82\n  変数 output に 0 を代入し、 while で n がある間\nn = 19 の場合、\n1の位を取得 19 % 10 = 9\n9 ** 2 = 81\noutput += 81\n10の位を取得 n = 19 // 10 = 1\nwhile で上記と同様の処理。 このループで n = 1 // 10 = 0\nとなり、ループを抜ける。\ncycle に入ったかの調べ方。 HashSet を使い、すでに訪れた数かを調べる。 すでに訪れた場合、 cycle に入ったことがわかるので、 その時点で False を返す。 もし訪れてなければ、HashSet に追加。 n == 1 となれば True を返す。  class Solution: def isHappy(self, n: int) -\u0026gt; bool: visit = set() while n not in visit: visit.add(n) n = self.sum_of_squares(n) if n == 1: return True return False def sum_of_squares(self, n: int) -\u0026gt; int: output = 0 while n: digit = n % 10 digit = digit ** 2 output += digit n = n // 10 return output ","permalink":"https://hirotoshimizu.github.io/posts/happy-number/","summary":"パターン1 7 → 49 → 97 → 130 → 10 → 1\nパターン2 2 → 4 → 16 → 37 → 30 → 9 → 81 → 65 → 61 → 37\nAlgorithm\n  number n の次の数が何かを調べる\n  cycle に入ったかを調べる。\n  の調べ方 19 → 1^2 + 9^2 = 82\n  変数 output に 0 を代入し、 while で n がある間\nn = 19 の場合、\n1の位を取得 19 % 10 = 9","title":"Happy Number"},{"content":"https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\n一番最後が -1 になるので、 変数 right_max に -1 を入れる。\n後ろからループしていき、 現在の値 と right_max の大きい値を new_max に入れる。 現在の値に right_max を代入し、 right_max の値に nex_max を代入しループを続ける。\n | 17 | 18 | 5 | 4 | 6 | 1 | -1 18 6 6 6 1 -1\nclass Solution: def replaceElements(self, arr: List[int]) -\u0026gt; List[int]: right_max = -1 for i in range(len(arr) -1, -1, -1): new_max = max(right_max, arr[i]) arr[i] = right_max right_max = new_max ","permalink":"https://hirotoshimizu.github.io/posts/replace-elements-with-greatest-element-on-right-side/","summary":"https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\n一番最後が -1 になるので、 変数 right_max に -1 を入れる。\n後ろからループしていき、 現在の値 と right_max の大きい値を new_max に入れる。 現在の値に right_max を代入し、 right_max の値に nex_max を代入しループを続ける。\n | 17 | 18 | 5 | 4 | 6 | 1 | -1 18 6 6 6 1 -1\nclass Solution: def replaceElements(self, arr: List[int]) -\u0026gt; List[int]: right_max = -1 for i in range(len(arr) -1, -1, -1): new_max = max(right_max, arr[i]) arr[i] = right_max right_max = new_max ","title":"Replace Elements With Greatest Element on Right Side"},{"content":"この問題の解き方は pointer を2つ使う。\n  真ん中を探す Pointer を2つ使い、fast pointer と fast.next が null になるまで Pinter を進める。 その際 slow pointer が真ん中に位置する。\n  後ろ半分を反転させる slow pointer が真ん中に位置しているので、 slow が null になるまでループさせる。\nstep.1 1 → 2 → 3 → null\nprev と curr を憶えておく必要がある。\nprev = null curr = 1\ncurr の next node を temp に入れておく。 temp = 2\nnull ← 1 2 → 3 → null\nstep.2 prev = 1 curr = 2 temp = 3\nnull ← 1 ← 2 3 → null\nstep.3 prev = 2 curr = 3 temp = null\nnull ← 1 ← 2 ← 3 null\nstep.4 prev = 3 curr = null temp = null\n  左半分と右半分を比べる。 違う場合は、その時点で false を返す。 同じ場合は、left と right を next に移動させて比較していく。\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def isPalindrome(self, head: Optional[ListNode]) -\u0026gt; bool: fast = head slow = head # find middle(slow) while fast and fast.next: fast = fast.next.next slow = slow.next # reverser second half prev = None while slow: temp = slow.next slow.next = prev prev = slow slow = temp # check palindrome left, right = head, prev while right: if left.val != right.val: return False left = left.next right = right.next return True ","permalink":"https://hirotoshimizu.github.io/posts/palindrome-linked-list/","summary":"この問題の解き方は pointer を2つ使う。\n  真ん中を探す Pointer を2つ使い、fast pointer と fast.next が null になるまで Pinter を進める。 その際 slow pointer が真ん中に位置する。\n  後ろ半分を反転させる slow pointer が真ん中に位置しているので、 slow が null になるまでループさせる。\nstep.1 1 → 2 → 3 → null\nprev と curr を憶えておく必要がある。\nprev = null curr = 1\ncurr の next node を temp に入れておく。 temp = 2\nnull ← 1 2 → 3 → null\nstep.2 prev = 1 curr = 2 temp = 3","title":"Palindrome Linked List"},{"content":"https://leetcode.com/problems/merge-sorted-array/\nこの問題は pointer を 3つ使う。 1つ目は、nums1 の最後に pointer を設定。 2つ目は、nums1 の m に pointer を設定。 3つ目は、nums2 の 最後に pointer を設定。\n | 1 | 2 | 3 | 0 | 0 | 0 |  ↑ ↑   | 2 | 5 | 6 |  ↑  nums1[m - 1] と nums2[n - 1] の値を比べて、 nums2[n - 1] の値が大きいので、 nums1[last] = nums2[n - 1] を設定する。 そして nums2 の n の pointer を -1 してずらす。 また nums1 の last の pointer も -1 する。\n | 1 | 2 | 3 | 0 | 0 | 6 |  ↑ ↑   | 2 | 5 | 6 |  ↑   | 1 | 2 | 3 | 0 | 5 | 6 |  ↑ ↑   | 2 | 5 | 6 | ↑\n | 1 | 2 | 3 | 3 | 5 | 6 |  ↑ ↑   | 2 | 5 | 6 | ↑\n | 1 | 2 | 2 | 3 | 5 | 6 |  ↑ ↑   | 2 | 5 | 6 | ↑\nwhile を抜ける。\nもし nums1 の最初の数（一番小さい数）が nums2 の最初の数より大きい場合、 上記の while 文だと merge されないので、 while n \u0026gt; 0: で nums2 の残りを nums1 に入れる。\nclass Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums1 in-place instead. \u0026#34;\u0026#34;\u0026#34; # last index nums1 last = m + n -1 # merget in reverse order while m \u0026gt; 0 and n \u0026gt; 0: if nums1[m - 1] \u0026gt; nums2[n - 1]: nums1[last] = nums1[m - 1] m -= 1 else: nums1[last] = nums2[n - 1] n -= 1 last -= 1 # fill nums1 with leftover nums2 elements while n \u0026gt; 0: nums1[last] = nums2[n - 1] n, last = n -1, last - 1 ","permalink":"https://hirotoshimizu.github.io/posts/merge-sorted-array/","summary":"https://leetcode.com/problems/merge-sorted-array/\nこの問題は pointer を 3つ使う。 1つ目は、nums1 の最後に pointer を設定。 2つ目は、nums1 の m に pointer を設定。 3つ目は、nums2 の 最後に pointer を設定。\n | 1 | 2 | 3 | 0 | 0 | 0 |  ↑ ↑   | 2 | 5 | 6 |  ↑  nums1[m - 1] と nums2[n - 1] の値を比べて、 nums2[n - 1] の値が大きいので、 nums1[last] = nums2[n - 1] を設定する。 そして nums2 の n の pointer を -1 してずらす。 また nums1 の last の pointer も -1 する。","title":"Merge Sorted Array"},{"content":"https://leetcode.com/problems/house-robber/\n隣り合った家は訪れることが出来ないので、 変数 rob1 と rob2 を用意する。\nfor で全ての家を訪れ、 pointer のある位置＋rob1 と rob2 の大きい値を temp に入れる。\nrob1 pointerのある位置の前の前の家 rob2 pointerのある位置のは前の家\nrob2 が nums の最後の位置まで行くとループが終わるので return で rob2 を返す。\nclass Solution: def rob(self, num: List[int])-\u0026gt; int: rob1, rob2 = 0, 0 for n in num: temp = max(rob1 + n, rob2) rob1 = rob2 rob2 = temp return rob2 ","permalink":"https://hirotoshimizu.github.io/posts/house-robber/","summary":"https://leetcode.com/problems/house-robber/\n隣り合った家は訪れることが出来ないので、 変数 rob1 と rob2 を用意する。\nfor で全ての家を訪れ、 pointer のある位置＋rob1 と rob2 の大きい値を temp に入れる。\nrob1 pointerのある位置の前の前の家 rob2 pointerのある位置のは前の家\nrob2 が nums の最後の位置まで行くとループが終わるので return で rob2 を返す。\nclass Solution: def rob(self, num: List[int])-\u0026gt; int: rob1, rob2 = 0, 0 for n in num: temp = max(rob1 + n, rob2) rob1 = rob2 rob2 = temp return rob2 ","title":"House Robber"},{"content":"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\nこの問題は pointer を2つ使い target になる数を探していく。\npointer を left と right に置き、 left と right の合計が target の値と同じかを計算する。\n合計が大きい場合は right の pointer を左にずらし、 合計が小さい場合は left の pointer を右にずらしていく。\n合計がtarget の値になるまでループして index の位置を返す。\ntarget = 9\n | 1 | 3 | 4 | 5 | 7 | 11 | 　↑　↑\n1 + 11 = 12 \u0026gt; 9\n | 1 | 3 | 4 | 5 | 7 | 11 | 　↑　↑\n1 + 7 = 8 \u0026lt; 9\n | 1 | 3 | 4 | 5 | 7 | 11 | 　↑　↑\n3 + 7 = 10 \u0026gt; 9\n | 1 | 3 | 4 | 5 | 7 | 11 | 　↑　↑\n3 + 5 = 8 \u0026lt; 9\n | 1 | 3 | 4 | 5 | 7 | 11 | 　↑　↑\n4 + 5 = 9\n[3,4]\nclass Solution: def twoSum(self, numbers: List[int], target: int) -\u0026gt; List[int]: left = 0 right = len(numbers) - 1 while left \u0026lt; right: total = numbers[left] + numbers[right] if total \u0026gt; target: right -= 1 elif total \u0026lt; target: left += 1 else: return [left +1, right + 1] return [] ","permalink":"https://hirotoshimizu.github.io/posts/two-sum-ii-input-array-is-sorted/","summary":"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\nこの問題は pointer を2つ使い target になる数を探していく。\npointer を left と right に置き、 left と right の合計が target の値と同じかを計算する。\n合計が大きい場合は right の pointer を左にずらし、 合計が小さい場合は left の pointer を右にずらしていく。\n合計がtarget の値になるまでループして index の位置を返す。\ntarget = 9\n | 1 | 3 | 4 | 5 | 7 | 11 | 　↑　↑\n1 + 11 = 12 \u0026gt; 9\n | 1 | 3 | 4 | 5 | 7 | 11 | 　↑　↑","title":"Two Sum Ii Input Array Is Sorted"},{"content":"https://leetcode.com/problems/find-the-town-judge/\ngraphの問題で、trust のペア, [a, b] は a から b に向かう directed edge である。\n例えば、 N = 5 で trust trust = [[1,3],[2,3],[4,3],[4,1],[5,3],[5,1],[5,4]] の場合下記のような graph になる。\n3 は 1,2,4,5 から信頼されていて、 誰も信頼していない。 そのため、judge は 3 になる。\nこの graph theory の、 outdegree の辺は、 その人が他の人を信頼している数になる。\nindegree の辺は他の人から信頼されている数になる。\nそのため indegree と outdegree によって誰が judge か判断できる。\njudge は outdegree が 0 で indegree が N - 1 となる。\ntrust をループして全員の indegree, outdegree の数を調査できる。\nindegree = [0] * (N + 1) outdegree = [0] * (N + 1) for a, b in trust: outdegree[a] += 1 indegree[b] += 1 そして、1 ～ N 人全員をループして、チェックすれば、 judge がわかる。\nfor i in range(1, N + 1): if indegree[i] == N - 1 and outdegree[i] == 0: return i return -1 Time complexity: O(E)\nMem complexity: O(n)\ndef findJudge(self, N: int, trust: List[List[int]]) -\u0026gt; int: if len(trust) \u0026lt; N - 1: return -1 indegree = [0] * (N + 1) outdegree = [0] * (N + 1) for a, b in trust: outdegree[a] += 1 indegree[b] += 1 for i in range(1, N + 1): if indegree[i] == N - 1 and outdegree[i] == 0: return i return -1 ","permalink":"https://hirotoshimizu.github.io/posts/find-the-town-judge/","summary":"https://leetcode.com/problems/find-the-town-judge/\ngraphの問題で、trust のペア, [a, b] は a から b に向かう directed edge である。\n例えば、 N = 5 で trust trust = [[1,3],[2,3],[4,3],[4,1],[5,3],[5,1],[5,4]] の場合下記のような graph になる。\n3 は 1,2,4,5 から信頼されていて、 誰も信頼していない。 そのため、judge は 3 になる。\nこの graph theory の、 outdegree の辺は、 その人が他の人を信頼している数になる。\nindegree の辺は他の人から信頼されている数になる。\nそのため indegree と outdegree によって誰が judge か判断できる。\njudge は outdegree が 0 で indegree が N - 1 となる。\ntrust をループして全員の indegree, outdegree の数を調査できる。\nindegree = [0] * (N + 1) outdegree = [0] * (N + 1) for a, b in trust: outdegree[a] += 1 indegree[b] += 1 そして、1 ～ N 人全員をループして、チェックすれば、 judge がわかる。","title":"Find the Town Judge"},{"content":"DFS\nBase Case root が Null は None を返す。\nTree を反転して値が同じなら True を返すので、\nchildren node の値を swap して同じか確かめる。\nTime complexity: O(n)\nMem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def invertTree(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; if not root: return None tmp = root.left root.left = root.right root.right = tmp self.invertTree(root.left) self.invertTree(root.right) return root ","permalink":"https://hirotoshimizu.github.io/posts/invert-binary-tree/","summary":"DFS\nBase Case root が Null は None を返す。\nTree を反転して値が同じなら True を返すので、\nchildren node の値を swap して同じか確かめる。\nTime complexity: O(n)\nMem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def invertTree(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; if not root: return None tmp = root.","title":"Invert Binary Tree"},{"content":"DFS recursive\nBase Case は p,q が Null の場合同じ Tree なので return する。\nもし p,q のどちらかの値が違う場合、その Tree は同じではないので、 False を return する。 また、どちらかの値が Null の場合同じ Tree ではないので、この場合も False を　return する。\nTime complexity: O(n) Mem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSameTree(self, p, q): \u0026#34;\u0026#34;\u0026#34; :type p: TreeNode :type q: TreeNode :rtype: bool \u0026#34;\u0026#34;\u0026#34; if not p and not q: return True if not p or not q or p.val != q.val: return False return(self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)) ","permalink":"https://hirotoshimizu.github.io/posts/same-tree/","summary":"DFS recursive\nBase Case は p,q が Null の場合同じ Tree なので return する。\nもし p,q のどちらかの値が違う場合、その Tree は同じではないので、 False を return する。 また、どちらかの値が Null の場合同じ Tree ではないので、この場合も False を　return する。\nTime complexity: O(n) Mem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSameTree(self, p, q): \u0026#34;\u0026#34;\u0026#34; :type p: TreeNode :type q: TreeNode :rtype: bool \u0026#34;\u0026#34;\u0026#34; if not p and not q: return True if not p or not q or p.","title":"Same Tree"},{"content":"回答のアプローチは Recursive DFS BFS Iterative DFS\nBase case root が empty children が Null\nRecursive DFS\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def maxDepth(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: int \u0026#34;\u0026#34;\u0026#34; if not root: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) BFS\nBFS を使う場合は Queue を使う。\n 3  ／　＼ 9 20 ／＼ 15 7\n | 3 | 9 | 20 | 15 | 7 | 1 2 2 3 3 ← Level\n | 3 | 1\nQueue を deque していくと 最終的に Queue の値がなくなるので、 その時に level を返す。\nif not root: retunr 0 level = 0 q = deque([root]) while q: for i in range(len(q)): node = q.popleft() if node.left: q.append(node.left) if node.right: q.append(node.right) level += 1 return level Iterative DFS\nPre-order DFS\nstack\n | node depth | | 3 1 | pop して\n | node depth | | 20 2 | | 9 2 | pop して\n | node depth | | 20 2 | 20 には子がいるので、stack に追加\n | node depth | | 7 3 | | 15 3 | stack = [[root, 1]] res = 0 while stack: node, depth = stack.pop() if node: res = max(res, depth) stack.append([node.left, depth + 1]) stack.append([node.right, depth + 1]) return res ","permalink":"https://hirotoshimizu.github.io/posts/maximum-depth-of-binary-tree/","summary":"回答のアプローチは Recursive DFS BFS Iterative DFS\nBase case root が empty children が Null\nRecursive DFS\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def maxDepth(self, root): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :rtype: int \u0026#34;\u0026#34;\u0026#34; if not root: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) BFS\nBFS を使う場合は Queue を使う。\n 3  ／　＼ 9 20 ／＼ 15 7\n | 3 | 9 | 20 | 15 | 7 | 1 2 2 3 3 ← Level","title":"Maximum Depth of Binary Tree"},{"content":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\nこの問題の回答方法としては Recursive と Iterative なアプローチがある。\nRecursive Approach\nアルゴリズム\n ルートの Node から始める。 p と q が右の subtree にある場合、1から右のsubtreeを探すようにする。 p と q が左の subtree にある場合、1から左のsubtreeを探すようにする。 もし 2 と 3 のステップが not true の場合、p と q の共通の Node を見つけたこととなる。  Time complexity: O(n)\nMem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def lowestCommonAncestor(self, root, p, q): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; parent_val = root.val p_val = p.val q_val = q.val if p_val \u0026gt; parent_val and q_val \u0026gt; parent_val: return self.lowestCommonAncestor(root.right, p, q) elif p_val \u0026lt; parent_val and q_val \u0026lt; parent_val: return self.lowestCommonAncestor(root.left, p, q) else: return root Iterative Approach\nアルゴリズム\nやり方としては Recursive なアプローチと似ている。 違いとしては、recursive な function を呼ぶ代わりに、tree を 横断する。\nそのため、backtrace して、LCA node を探す必要がないため stack,recursion を使わない。 Iterative なやり方としては、分かれるポイントを探すこと。\nTime complexity: O(n)\nMem complexity: O(1)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def lowestCommonAncestor(self, root, p, q): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; cur = root while cur: if p.val \u0026gt; cur.val and q.val \u0026gt; cur.val: cur = cur.right elif p.val \u0026lt; cur.val and q.val \u0026lt; cur.val: cur = cur.left else: return cur ","permalink":"https://hirotoshimizu.github.io/posts/lowest-common-ancestor-of-a-binary-search-tree/","summary":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\nこの問題の回答方法としては Recursive と Iterative なアプローチがある。\nRecursive Approach\nアルゴリズム\n ルートの Node から始める。 p と q が右の subtree にある場合、1から右のsubtreeを探すようにする。 p と q が左の subtree にある場合、1から左のsubtreeを探すようにする。 もし 2 と 3 のステップが not true の場合、p と q の共通の Node を見つけたこととなる。  Time complexity: O(n)\nMem complexity: O(n)\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def lowestCommonAncestor(self, root, p, q): \u0026#34;\u0026#34;\u0026#34; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; parent_val = root.","title":"Lowest Common Ancestor of a Binary Search Tree"},{"content":"https://leetcode.com/problems/climbing-stairs/\nn = 5\n 0 ／　＼ 1 2 ／＼ ／＼ 2 3 3 4 ／＼ ／＼ ／＼ ／＼ 3 4 4 5 4 5 5 6  ／＼ ／＼ ／＼　／＼ 4 5 5 6 5 6　5 6 ／＼ 5 6\nn が 5 steps の場合、 8通りの選択が出来る。\nDFS でも出来るかが 2^n となる。\nそのため Dynamic Programming を使う。\n同じ計算をする値は memoize する\n | 8 | 5 | 3 | 2 | 1 | 1 | n に辿り着くまでの数 0 1 2 3 4 5(step) one two\nn に辿り着くまでの数はBase Number を基に計算できる。\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def climbStairs(self, n): \u0026#34;\u0026#34;\u0026#34; :type n: int :rtype: int \u0026#34;\u0026#34;\u0026#34; one, two = 1, 1 for i in n: temp = one one = one + two two = temp return one ","permalink":"https://hirotoshimizu.github.io/posts/climbing-stairs/","summary":"https://leetcode.com/problems/climbing-stairs/\nn = 5\n 0 ／　＼ 1 2 ／＼ ／＼ 2 3 3 4 ／＼ ／＼ ／＼ ／＼ 3 4 4 5 4 5 5 6  ／＼ ／＼ ／＼　／＼ 4 5 5 6 5 6　5 6 ／＼ 5 6\nn が 5 steps の場合、 8通りの選択が出来る。\nDFS でも出来るかが 2^n となる。\nそのため Dynamic Programming を使う。\n同じ計算をする値は memoize する\n | 8 | 5 | 3 | 2 | 1 | 1 | n に辿り着くまでの数 0 1 2 3 4 5(step) one two","title":"Climbing Stairs"},{"content":"https://leetcode.com/problems/meeting-rooms/\n先ず始めに intervals のスタート時間でソートする。\nintervals の時間がソートされたため、 ループで最初の会議の終わりの時間と次の会議の始まりの時間を比較し、 最初の会議の終わりの時間 が 次の会議の始まりの時間より大きい場合、 会議の時間が重なっているので、False を返す。\n次の会議の開始時間 が 前の会議の終わり時間より小さい場合ループを続ける。\nループする際、次のリストと比較するため for の range で -1 をする。\nソートをするので Time complexity は O(n log n) となる。\nTime complexity: O(n log n) Mem complexity: O(1)\nclass Solution(object): def canAttendMeetings(self, intervals): \u0026#34;\u0026#34;\u0026#34; :type intervals: List[List[int]] :rtype: bool \u0026#34;\u0026#34;\u0026#34; intervals.sort() for i in range(len(intervals) -1): if intervals[i][1] \u0026gt; intervals[i + 1][0]: return False return True ","permalink":"https://hirotoshimizu.github.io/posts/meeting-rooms/","summary":"https://leetcode.com/problems/meeting-rooms/\n先ず始めに intervals のスタート時間でソートする。\nintervals の時間がソートされたため、 ループで最初の会議の終わりの時間と次の会議の始まりの時間を比較し、 最初の会議の終わりの時間 が 次の会議の始まりの時間より大きい場合、 会議の時間が重なっているので、False を返す。\n次の会議の開始時間 が 前の会議の終わり時間より小さい場合ループを続ける。\nループする際、次のリストと比較するため for の range で -1 をする。\nソートをするので Time complexity は O(n log n) となる。\nTime complexity: O(n log n) Mem complexity: O(1)\nclass Solution(object): def canAttendMeetings(self, intervals): \u0026#34;\u0026#34;\u0026#34; :type intervals: List[List[int]] :rtype: bool \u0026#34;\u0026#34;\u0026#34; intervals.sort() for i in range(len(intervals) -1): if intervals[i][1] \u0026gt; intervals[i + 1][0]: return False return True ","title":"Meeting Rooms"},{"content":"https://leetcode.com/problems/merge-two-sorted-lists/\nダミー Node を作って edge case の 空の Linked List が挿入されても大丈夫なようにする。\nその後はループで l1 と l2 の val を比べ、 小さい値を tail.next に入れる。 その後、 next をずらす。\nループ後 l1, l2 のどちらかのリストが empty の場合、 Linked List に追加する必要があるので、 リストが empty か確認し、値があれば Linked List に追加する。\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeTwoLists(self, l1, l2): \u0026#34;\u0026#34;\u0026#34; :type l1: ListNode :type l2: ListNode :rtype: ListNode \u0026#34;\u0026#34;\u0026#34; dummy = ListNode() tail = dummy while l1 and l2: if l1.val \u0026lt; l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 elif l2: tail.next = 12 return dummy.next ","permalink":"https://hirotoshimizu.github.io/posts/merge-two-sorted-lists/","summary":"https://leetcode.com/problems/merge-two-sorted-lists/\nダミー Node を作って edge case の 空の Linked List が挿入されても大丈夫なようにする。\nその後はループで l1 と l2 の val を比べ、 小さい値を tail.next に入れる。 その後、 next をずらす。\nループ後 l1, l2 のどちらかのリストが empty の場合、 Linked List に追加する必要があるので、 リストが empty か確認し、値があれば Linked List に追加する。\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeTwoLists(self, l1, l2): \u0026#34;\u0026#34;\u0026#34; :type l1: ListNode :type l2: ListNode :rtype: ListNode \u0026#34;\u0026#34;\u0026#34; dummy = ListNode() tail = dummy while l1 and l2: if l1.","title":"Merge Two Sorted Lists"},{"content":"https://leetcode.com/problems/linked-list-cycle/\nLinked List が Cycle なのかを確認する。\nLinked List が Cycle な場合、 2つのポインターを使う。 (1つめのポインターは 1つずつ進み、 2つめのポインターは 2つずつ進む。) Cycle な場合どこかの時点で2つ進むポインター が1つしか進まないポインターに追いつくので Cycle だとわかる。\nCycle ではない場合 いずれかの時点で ポインターが Null になる。\nTime complexity: O(n) Mem complexity: O(1)\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \u0026#34;\u0026#34;\u0026#34; :type head: ListNode :rtype: bool \u0026#34;\u0026#34;\u0026#34; slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if fast == slow: return True return False ","permalink":"https://hirotoshimizu.github.io/posts/linked-list-cycle/","summary":"https://leetcode.com/problems/linked-list-cycle/\nLinked List が Cycle なのかを確認する。\nLinked List が Cycle な場合、 2つのポインターを使う。 (1つめのポインターは 1つずつ進み、 2つめのポインターは 2つずつ進む。) Cycle な場合どこかの時点で2つ進むポインター が1つしか進まないポインターに追いつくので Cycle だとわかる。\nCycle ではない場合 いずれかの時点で ポインターが Null になる。\nTime complexity: O(n) Mem complexity: O(1)\n# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \u0026#34;\u0026#34;\u0026#34; :type head: ListNode :rtype: bool \u0026#34;\u0026#34;\u0026#34; slow, fast = head, head while fast and fast.","title":"Linked List Cycle"},{"content":"https://leetcode.com/problems/reverse-linked-list/\n考え方としては、\n1 → 2 → 3 → 4 → 5\n1 ← 2 ← 3 ← 4 ← 5\nとするように考える。\n回答方法は iterative なやり方と recursive なやり方がある。 iterative なやり方は 2つの pointer を使う。\nprev と curr\nまず prev に　None を設定する。 curr は head にする\nNull → 1 → 2 → 3 → 4 → 5 ↑ ↑ prev curr\nループしている間 Linked List の 矢印の向き (curr.next) をずらしつつ、prev と next の pointer もずらしていく。\nNull ← 1 → 2 → 3 → 4 → 5 → Null ↑ ↑ prev curr\nNull ← 1 ← 2 → 3 → 4 → 5 → Null ↑ ↑ prev curr\nNull ← 1 ← 2 ← 3 → 4 → 5 → Null ↑ ↑ prev curr\nNull ← 1 ← 2 ← 3 ← 4 → 5 → Null ↑ ↑ prev curr\nNull ← 1 ← 2 ← 3 ← 4 ← 5 → Null ↑ ↑ prev curr\ncurr が Null になりループを抜けるので、 最後に head を prev に設定する。\nTime complexity: O(n) Mem complexity: O(1)\n# Definition for singly-linked list. class ListNode(object): def __init__(self, val=0, next=None): self.val = val self.next = next class Solution(object): def reverseList(self, head): \u0026#34;\u0026#34;\u0026#34; :type head: ListNode :rtype: ListNode \u0026#34;\u0026#34;\u0026#34; prev = None curr = head while curr: nxt = curr.next curr.next = prev prev = curr curr = nxt return prev recursive\nhead: ListNode{val: 1, next: ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}}}} head: ListNode{val: 2, next: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}}} head: ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} head: ListNode{val: 4, next: ListNode{val: 5, next: None}} head: ListNode{val: 5, next: None}\nhead: ListNode{val: 4, next: ListNode{val: 5, next: None}} reversedListHead: ListNode{val: 5, next: None}\nhead: ListNode{val: 4, next: None} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: None}}\nhead: ListNode{val: 3, next: ListNode{val: 4, next: None}} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: None}}\nhead: ListNode{val: 3, next: None} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: None}}}\nhead: ListNode{val: 2, next: ListNode{val: 3, next: None}} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: None}}}\nhead: ListNode{val: 2, next: None} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: ListNode{val: 2, next: None}}}}\nhead: ListNode{val: 1, next: ListNode{val: 2, next: None}} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: ListNode{val: 2, next: None}}}}\nhead: ListNode{val: 1, next: None} reversedListHead: ListNode{val: 5, next: ListNode{val: 4, next: ListNode{val: 3, next: ListNode{val: 2, next: ListNode{val: 1, next: None}}}}}\nTime complexity: O(n) Mem complexity: O(n)\n","permalink":"https://hirotoshimizu.github.io/posts/reverse-linked-list/","summary":"https://leetcode.com/problems/reverse-linked-list/\n考え方としては、\n1 → 2 → 3 → 4 → 5\n1 ← 2 ← 3 ← 4 ← 5\nとするように考える。\n回答方法は iterative なやり方と recursive なやり方がある。 iterative なやり方は 2つの pointer を使う。\nprev と curr\nまず prev に　None を設定する。 curr は head にする\nNull → 1 → 2 → 3 → 4 → 5 ↑ ↑ prev curr\nループしている間 Linked List の 矢印の向き (curr.next) をずらしつつ、prev と next の pointer もずらしていく。","title":"Reverse Linked List"},{"content":"https://leetcode.com/problems/valid-parentheses/\nPrerequisite Hash Map Stack\n最初にどのカッコがどの 括弧閉じ にマッチしているかわかるために HashMap を作る必要がある。 この際、括弧閉じ をキーにする。\nfor 文で list の中を確認し、 括弧開きは stack に入れる。\nstack は 最後に入れたものから出すので、 括弧開き と 括弧閉じ がマッチしていれば、 stack から pop できる。\n最後に stack に何も残らなければ、 全てがマッチして True を return する。\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def isValid(self, s): \u0026#34;\u0026#34;\u0026#34; :type s: str :rtype: bool \u0026#34;\u0026#34;\u0026#34; stack = [] closeToOpen = { \u0026#39;)\u0026#39; : \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39; : \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39; : \u0026#39;{\u0026#39; } for c in s: if c in closeToOpen: if stack and stack[-1] == closeToOpen[c]: stack.pop() else: return False else: stack.append(c) return True if not stack else False ","permalink":"https://hirotoshimizu.github.io/posts/valid-parentheses/","summary":"https://leetcode.com/problems/valid-parentheses/\nPrerequisite Hash Map Stack\n最初にどのカッコがどの 括弧閉じ にマッチしているかわかるために HashMap を作る必要がある。 この際、括弧閉じ をキーにする。\nfor 文で list の中を確認し、 括弧開きは stack に入れる。\nstack は 最後に入れたものから出すので、 括弧開き と 括弧閉じ がマッチしていれば、 stack から pop できる。\n最後に stack に何も残らなければ、 全てがマッチして True を return する。\nTime complexity: O(n) Mem complexity: O(n)\nclass Solution(object): def isValid(self, s): \u0026#34;\u0026#34;\u0026#34; :type s: str :rtype: bool \u0026#34;\u0026#34;\u0026#34; stack = [] closeToOpen = { \u0026#39;)\u0026#39; : \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39; : \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39; : \u0026#39;{\u0026#39; } for c in s: if c in closeToOpen: if stack and stack[-1] == closeToOpen[c]: stack.","title":"Valid Parentheses"},{"content":"https://leetcode.com/problems/missing-number/\nsum([0,1,2,3]) - sum([3,0,1]) = 2 2がない数字なので、2が残る。\n最初に result に len(nums) を代入する。 nums が [3,0,1] の場合、 result に 3 が代入される。\nこれは for で回す時に range(len(nums)) だと 0, 1, 2 としかならないため。 result に len(nums) の代入が必要。\nresult += (i - nums[i]) をすることで、2 が return 出来る。\nTime complexity: O(n) Mem complexity: O(1)\nclass Solution(object): def missingNumber(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; result = len(nums) for i in range(len(nums)): result += (i - nums[i]) return result ","permalink":"https://hirotoshimizu.github.io/posts/missing-number/","summary":"https://leetcode.com/problems/missing-number/\nsum([0,1,2,3]) - sum([3,0,1]) = 2 2がない数字なので、2が残る。\n最初に result に len(nums) を代入する。 nums が [3,0,1] の場合、 result に 3 が代入される。\nこれは for で回す時に range(len(nums)) だと 0, 1, 2 としかならないため。 result に len(nums) の代入が必要。\nresult += (i - nums[i]) をすることで、2 が return 出来る。\nTime complexity: O(n) Mem complexity: O(1)\nclass Solution(object): def missingNumber(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; result = len(nums) for i in range(len(nums)): result += (i - nums[i]) return result ","title":"Missing Number"},{"content":"https://leetcode.com/problems/maximum-subarray/\n | -2 | 1 | -3 | 4 | -1 | 2 | 1 | -5 | 4 | 最初の3つの合計(-2 + 1 -3)はマイナスになるので、 そのため subarray のスタートは 4 もしくは 4以降の数字になる。\n合計が正の数になる場合は保持しておく。 変数に0 を代入して、 iterate しながら数字を追加していく。 合計がマイナスになる場合は保持する必要がないので、0 にする。\nTime complexity: O(n) Mem complexity: O(1)\nclass Solution(object): def maxSubArray(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; max_subarray = nums[0] current_subarray = 0 for n in nums: if current_subarray \u0026lt; 0: current_subarray = 0 current_subarray += n max_subarray = max(max_subarray, current_subarray) return max_subarray ","permalink":"https://hirotoshimizu.github.io/posts/maximum-subarray/","summary":"https://leetcode.com/problems/maximum-subarray/\n | -2 | 1 | -3 | 4 | -1 | 2 | 1 | -5 | 4 | 最初の3つの合計(-2 + 1 -3)はマイナスになるので、 そのため subarray のスタートは 4 もしくは 4以降の数字になる。\n合計が正の数になる場合は保持しておく。 変数に0 を代入して、 iterate しながら数字を追加していく。 合計がマイナスになる場合は保持する必要がないので、0 にする。\nTime complexity: O(n) Mem complexity: O(1)\nclass Solution(object): def maxSubArray(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; max_subarray = nums[0] current_subarray = 0 for n in nums: if current_subarray \u0026lt; 0: current_subarray = 0 current_subarray += n max_subarray = max(max_subarray, current_subarray) return max_subarray ","title":"Maximum Subarray"},{"content":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\npointer を2つ使う。 left が right より低い時点で売る可能性あり。 max_profit に最大の profit を格納。\nright の pointer は右に移動し続け\nleft の　pointer は prices[l] が prices[r] より大きい際に、 left の pointer を right の pointer の位置に移動する。\nTime complexity: O(n)\nMem complexity: O(1)\nclass Solution(object): def maxProfit(self, prices): \u0026#34;\u0026#34;\u0026#34; :type prices: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; l, r = 0, 1 max_profit = 0 while r \u0026lt; len(prices): if prices[l] \u0026lt; prices[r]: profit = prices[r] - prices[l] max_profit = max(max_profit, profit) else: l = r r += 1 return max_profit ","permalink":"https://hirotoshimizu.github.io/posts/best-time-to-buy-and-sell-stock/","summary":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\npointer を2つ使う。 left が right より低い時点で売る可能性あり。 max_profit に最大の profit を格納。\nright の pointer は右に移動し続け\nleft の　pointer は prices[l] が prices[r] より大きい際に、 left の pointer を right の pointer の位置に移動する。\nTime complexity: O(n)\nMem complexity: O(1)\nclass Solution(object): def maxProfit(self, prices): \u0026#34;\u0026#34;\u0026#34; :type prices: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; l, r = 0, 1 max_profit = 0 while r \u0026lt; len(prices): if prices[l] \u0026lt; prices[r]: profit = prices[r] - prices[l] max_profit = max(max_profit, profit) else: l = r r += 1 return max_profit ","title":"Best Time to Buy and Sell Stock"},{"content":"https://leetcode.com/problems/two-sum/\n | 2 | 7 | 11 | 15 | 　↑　↑ 全てのコンビネーションを確認しようと Brute Force で問題を解こうとすると ループの中でループをするのでo(n^2)となる。\n | 2 | 7 | 11 | 15 | そのため HashMapを使う必要がある。 ループして array の中を確認する際に、 HashMap に val と key を持たせる。 ループ時に target - val の値が HashMap にあれば、 合計の値を持つ index が return できる。\n | 2 | 7 | 11 | 15 |  ↑   | HashMap | | val : index | | 2 : 1 |  | HashMap | | val : index | | 2 : 1 | | 7 : 2 |← | 11 : 3 | | 15 : 4 | target は 9 なので val 7 を確認時に HashMap にすでに 2 が入っているので この時点で return できる。\n一度だけのループなので、 Time complexity: O(n) Mem complexity: O(n) となる。\nclass Solution(object): def twoSum(self, nums, target): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; map = {} for i, n in enumerate(nums): diff = target - n if diff in map: return [map[diff], i] map[n] = i ","permalink":"https://hirotoshimizu.github.io/posts/two-sum/","summary":"https://leetcode.com/problems/two-sum/\n | 2 | 7 | 11 | 15 | 　↑　↑ 全てのコンビネーションを確認しようと Brute Force で問題を解こうとすると ループの中でループをするのでo(n^2)となる。\n | 2 | 7 | 11 | 15 | そのため HashMapを使う必要がある。 ループして array の中を確認する際に、 HashMap に val と key を持たせる。 ループ時に target - val の値が HashMap にあれば、 合計の値を持つ index が return できる。\n | 2 | 7 | 11 | 15 |  ↑   | HashMap | | val : index | | 2 : 1 |  | HashMap | | val : index | | 2 : 1 | | 7 : 2 |← | 11 : 3 | | 15 : 4 | target は 9 なので val 7 を確認時に HashMap にすでに 2 が入っているので この時点で return できる。","title":"Two Sum"},{"content":"Responses HttpResponse オブジェクトと違い、レンダリングされたコンテンツでResponseオブジェクトをインスタンス化する必要がない。 その代わりにレンダリングされていないデータをパスする必要がある。\nResponseクラスで使用されるレンダラーは、Djangoモデルインスタンスなどの複雑なデータ型をネイティブに処理できないため、Responseオブジェクトを作成する前に、データをプリミティブデータ型にシリアル化する必要があります。\nREST frameworkのSerializerクラスを使ってこのデータをシリアライズするか、カスタムシリアライザーを使用する。\n引数\n data : レスポンス用のシリアライズされたデータ status : レスポンス用のステータスコード　デフォルトでは 200 template_name : HTMLRenderer が選択されているならテンプレート名 header : レスポンス用の辞書型 HTTP ヘッダー content_type : レスポンス用のコンテンツタイプ。一般的にコンテンツネゴシエーションのrenderer によって自動的に設定される。しかし、場合によっては明示的にコンテンツタイプを特定する必要もある。  プロジェクトが既にある場合 ユーザーモデルは拡張する。\n最初から作成する場合は モデルをオーバーライドして独自のカスタムモデルを作成\nカスタムユーザーモデルは\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-29/","summary":"Responses HttpResponse オブジェクトと違い、レンダリングされたコンテンツでResponseオブジェクトをインスタンス化する必要がない。 その代わりにレンダリングされていないデータをパスする必要がある。\nResponseクラスで使用されるレンダラーは、Djangoモデルインスタンスなどの複雑なデータ型をネイティブに処理できないため、Responseオブジェクトを作成する前に、データをプリミティブデータ型にシリアル化する必要があります。\nREST frameworkのSerializerクラスを使ってこのデータをシリアライズするか、カスタムシリアライザーを使用する。\n引数\n data : レスポンス用のシリアライズされたデータ status : レスポンス用のステータスコード　デフォルトでは 200 template_name : HTMLRenderer が選択されているならテンプレート名 header : レスポンス用の辞書型 HTTP ヘッダー content_type : レスポンス用のコンテンツタイプ。一般的にコンテンツネゴシエーションのrenderer によって自動的に設定される。しかし、場合によっては明示的にコンテンツタイプを特定する必要もある。  プロジェクトが既にある場合 ユーザーモデルは拡張する。\n最初から作成する場合は モデルをオーバーライドして独自のカスタムモデルを作成\nカスタムユーザーモデルは","title":"2021 07 29"},{"content":"APIView REST frameworkは Djangoの View class のサブクラスである、 APIViewclassを提供する。\nAPIViewclass は下記のようにView classとは異なる。\n  handler methods を通ったRequests は REST frameworkの Request インスタンスになり。 Django の HttpRequestインスタンスではない。\n  handler methods の return は REST frameworkの Responseとなり、 その view は content negotiation と response に一致した renderer を返す。\n  どの APIException のエクセプションは正しいレスポンスに仲介される。\n  来るリクエストは認証され、handler methodsに送る前に、 適切な権限やスロットルチェックが行われる。\n  DRF ドキュメント\nViewSet viewSet classは APIViewを継承している。 viewsetで API policy をコントロールするにあたり、 スタンダードの属性であるpermission_classes,authentication_classesが使える。\nviewSet classはどのアクションも含んでいないので、 クラスをオーバーライドして明示的に定義する必要がある。\nDRF ドキュメント\nGenericViewSet GenericViewSetclass は GenericAPIViewを継承して、 デフォルトセットの get_object、get_querysetメソッドと その他の generic view base behaviorを提供する。 しかしデフォルトではどんなアクションも含まれない。\nGenericViewSetを使うにあたり、クラスのオーバーライドと 要求される mixn クラス もしくは、アクションを明示的に定義する必要がある。\nDRF ドキュメント\nModelViewSet ModelViewSet class は GenericAPIView を継承し、さまざまなミックスインクラスの動作を混合することにより、さまざまなアクションの実装を含みます。\nModelViewSet classによって提供されるアクションクラスは .list(),.retrieve(),.create(),.update(),.partial_update(),destroy()\nModelViewSet は GenericAPIViewを拡張しているので、 最低でも queryset と serializer_class属性だけで良い。\n例\nclass AccountViewSet(viewsets.ModelViewSet): \u0026#34;\u0026#34;\u0026#34; A simple ViewSet for viewing and editing accounts. \u0026#34;\u0026#34;\u0026#34; queryset = Account.objects.all() serializer_class = AccountSerializer permission_classes = [IsAccountAdminOrReadOnly] DRF ドキュメント\nMixins mixin クラスは basic view behaviorで使われるアクションを提供する。 mixin　クラスは .get(), .post()などのhabndler method を直接定義するのではなく、アクションメソッドを提供する。これにより柔軟に構成できる。\nmixin クラスは rest_framework.mixinsより import できる。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-28/","summary":"APIView REST frameworkは Djangoの View class のサブクラスである、 APIViewclassを提供する。\nAPIViewclass は下記のようにView classとは異なる。\n  handler methods を通ったRequests は REST frameworkの Request インスタンスになり。 Django の HttpRequestインスタンスではない。\n  handler methods の return は REST frameworkの Responseとなり、 その view は content negotiation と response に一致した renderer を返す。\n  どの APIException のエクセプションは正しいレスポンスに仲介される。\n  来るリクエストは認証され、handler methodsに送る前に、 適切な権限やスロットルチェックが行われる。\n  DRF ドキュメント\nViewSet viewSet classは APIViewを継承している。 viewsetで API policy をコントロールするにあたり、 スタンダードの属性であるpermission_classes,authentication_classesが使える。\nviewSet classはどのアクションも含んでいないので、 クラスをオーバーライドして明示的に定義する必要がある。","title":"2021 07 28"},{"content":"今回は restaurants というアプリを作成し進めていきます。\nCSVのファイルは管理画面のレストランの一覧画面 http://127.0.0.1:8000/admin/restaurants/restaurant/ からアップ。\nアプリの作成\npython manage.py startapp restaurants モデルは restaurant で作成。\nAdmin テンプレートの Override templatesフォルダは manage.py と同じ階層に作成。\ntemplates/admin/restaurants/restaurant/change_list.html を作成\n{% extends \u0026#39;admin/change_list.html\u0026#39; %} {% load static %} {% block content %} \u0026lt;a href=\u0026#34;upload-csv/\u0026#34;\u0026gt;Upload a csv file\u0026lt;/a\u0026gt; {{ block.super }} {% endblock %} {{ block.super }} は親のテンプレートコンテンツ。\nDjango change_list.html\nCustom Admin Page の作成 上記で作成したリンク先の upload-csv/ の URL を設定\nrestaurants/admin.py の RestaurantAdmin で get_urls()を設定。\ndef get_urls(self): urls = super().get_urls() new_urls = [ path(\u0026#39;upload-csv/\u0026#39;, self.upload_csv), ] return new_urls + urls Django ドキュメント\ntemplates/admin/csv_upload.htmlを作成\n{% extends 'admin/base.html' %} {% block content %} \u0026lt;div\u0026gt; \u0026lt;form action=\u0026quot;.\u0026quot; method=\u0026quot;POST\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; {{ form.as_p }} {% csrf_token %} \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Upload File\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; {% endblock %} csvファイルからのテーブル作成 RestaurantAdmin の get_urlsに記載した upload_csv の処理を追加。\ndef upload_csv(self, request): if request.method == \u0026#39;POST\u0026#39;: csv_file = request.FILES[\u0026#39;csv_upload\u0026#39;] file_data = csv_file.read().decode(\u0026#39;utf-8\u0026#39;) restaurants_data = file_data.split(\u0026#39;\\n\u0026#39;) for i in restaurants_data: fields = i.split(\u0026#34;,\u0026#34;) restaurant.objects.update_or_create( name=fields[0], address=fields[1], ) form = CsvImportForm() data = {\u0026#39;form\u0026#39;: form} return render(request, \u0026#39;admin/csv_upload.html\u0026#39;, data) update_or_create() を使用するので、 同じオブジェクトがあればアップデートされ、なければ作成される。\nフォームも必要なので、restaurants/admin.py　にフォームも用意。 class CsvImportForm(forms.Form): csv_upload = forms.FileField()\nこれで最低限のCSVからデータをアップロードできるかと思います。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-19/","summary":"今回は restaurants というアプリを作成し進めていきます。\nCSVのファイルは管理画面のレストランの一覧画面 http://127.0.0.1:8000/admin/restaurants/restaurant/ からアップ。\nアプリの作成\npython manage.py startapp restaurants モデルは restaurant で作成。\nAdmin テンプレートの Override templatesフォルダは manage.py と同じ階層に作成。\ntemplates/admin/restaurants/restaurant/change_list.html を作成\n{% extends \u0026#39;admin/change_list.html\u0026#39; %} {% load static %} {% block content %} \u0026lt;a href=\u0026#34;upload-csv/\u0026#34;\u0026gt;Upload a csv file\u0026lt;/a\u0026gt; {{ block.super }} {% endblock %} {{ block.super }} は親のテンプレートコンテンツ。\nDjango change_list.html\nCustom Admin Page の作成 上記で作成したリンク先の upload-csv/ の URL を設定\nrestaurants/admin.py の RestaurantAdmin で get_urls()を設定。\ndef get_urls(self): urls = super().get_urls() new_urls = [ path(\u0026#39;upload-csv/\u0026#39;, self.","title":"Djnagoの管理画面からCSVファイルをアップしてデータ登録"},{"content":"PrimaryKeyRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのプライマリーキーを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.PrimaryKeyRelatedField(source=\u0026#39;user\u0026#39;, read_only=True) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: 1, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.HyperlinkedRelatedField( source=\u0026#39;user\u0026#39;, # user foreign key lookup_field=\u0026#39;username\u0026#39;, view_name=\u0026#39;api-user:detail\u0026#39;, read_only=True ) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;] view_name  lookup_field リレーション関係にあるターゲット上のフィールド。 参照する view の URL キーワード引数と一致する必要がある。 デフォルトではpk\n \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot;, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user_id = serializers.HyperlinkedRelatedField( source=\u0026#39;user\u0026#39;, # user foreign key lookup_field=\u0026#39;username\u0026#39;, view_name=\u0026#39;api-user:detail\u0026#39;, read_only=True ) user = serializers.SlugRelatedField(read_only=True, slug_field=\u0026#39;username\u0026#39;) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/7/\u0026quot;, \u0026quot;user_id\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/hshimizu/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user\u0026quot;: \u0026quot;hshimizu\u0026quot;, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/hshimizu/images.png\u0026quot; }, DRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-14/","summary":"PrimaryKeyRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのプライマリーキーを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.PrimaryKeyRelatedField(source=\u0026#39;user\u0026#39;, read_only=True) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: 1, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.","title":"2021 07 13"},{"content":"Authenticating users authenticate(request=None, **credentials)\nauthenticate() は認証の承認のために使用する関数。 デフォルトでは keyword arguments で username と password で認証し、 User オブジェクトを返す。\nset_password(raw_password)\nパスワードをハッシュ化するのに使う。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-12/","summary":"Authenticating users authenticate(request=None, **credentials)\nauthenticate() は認証の承認のために使用する関数。 デフォルトでは keyword arguments で username と password で認証し、 User オブジェクトを返す。\nset_password(raw_password)\nパスワードをハッシュ化するのに使う。","title":"2021 07 12"},{"content":"python での JSON の扱いについてわすれるのでメモ。\njson.dumps json.dumps()に入れた変数を JSON string に変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' json.loads json.loads(JSON string) で python dictionary に型を変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' \u0026gt;\u0026gt;\u0026gt; load_json = json.loads(data_json) \u0026gt;\u0026gt;\u0026gt; load_json {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(load_json) \u0026lt;class 'dict'\u0026gt; \u0026gt;\u0026gt;\u0026gt; load_json['abc'] 123 Django Rest Framework\nSerializerでの Create, Update, Delete \u0026quot;\u0026rdquo;\u0026rdquo; Create obj \u0026quot;\u0026rdquo;\u0026rdquo;\ndata = {'user': 1} serializer = StatusSerializer(data=data) serializer.is_valid() # is_validでデータを検証しないと .save() でエラーが出る serializer.save() \u0026quot;\u0026rdquo;\u0026rdquo; Update obj \u0026quot;\u0026rdquo;\u0026rdquo;\nobj = Status.objects.first() data = {'content': 'some new content', 'user': 1} update_serializer = StatusSerializer(obj, data=data) update_serializer.is_valid() update_serializer.save update_serializer.errors {'user': ['This field is required.']} \u0026quot;\u0026rdquo;\u0026rdquo; Delete obj \u0026quot;\u0026rdquo;\u0026rdquo;\nobj = Status.objects.last() obj.delete() Delete は Serializerを使わず、objectを取得して削除。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-11/","summary":"python での JSON の扱いについてわすれるのでメモ。\njson.dumps json.dumps()に入れた変数を JSON string に変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' json.loads json.loads(JSON string) で python dictionary に型を変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' \u0026gt;\u0026gt;\u0026gt; load_json = json.loads(data_json) \u0026gt;\u0026gt;\u0026gt; load_json {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(load_json) \u0026lt;class 'dict'\u0026gt; \u0026gt;\u0026gt;\u0026gt; load_json['abc'] 123 Django Rest Framework","title":"2021 07 11"},{"content":"Web API the good parts\nエンドポイントの基本的な設計 覚えやすく、どんな機能を持つURIなのかがひと目でわかる  短くて入力しやすいURI 人間が読んで理解できるURL 大文字小文字が混在していないURI 改造しやすい（Hackableな）URI サーバー側のアーキテクチャが反映されていないURI  どんなソフトウェア、言語を利用しているのか。 ディレクトリやシステム構成がどうなっているのか。   ルールが統一されたURI  リソースにアクセスするための設計の注意点  複数形の名詞を利用する 利用する単語に気をつける スペースやエンコードを必要とする文字を使わない 単語をつなげる必要がある場合はハイフンを利用する  リソースの一覧取得のエンドポイントが検索を兼ねる。 絞り込み検索はパラメーターを設定する。\n検索に相対位置を利用する問題点 データ数が膨大になるとpageやoffsetを指定されていると「先頭から何件目か」を調べるために先頭から数を数える処理が行われるため遅くなる。 また、更新頻度が高いデータの場合データに不整合が生じる。\n絶対位置でデータを問題点 絶対位置指定とは、オフセットで相対位置を指定する代わりに、これまで取得した最後のデータのIDや時間を記録しておいて、「このIDより前のもの」や「この時刻より古いもの」と言った指定を行う方法。　配列とフォーマット オブジェクトで配列を包むメリット  レスポンスデータが何をしていものかがわかりやすくなる レスポンスデータをオブジェクトに統一することができる。 セキュリティ上のリスクを避けることができる  トップれべるが配列であるJSONは、JSONインジェクションに対するリスクが大きくなる。\n続きがある場合どうデータを返すべきか 例えば20件データを返すためには最大21件の取得を行ってみて、実際に21件取得できれば、 「hasNext」といった名前で結果を含めてあげれば良い。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-09/","summary":"Web API the good parts\nエンドポイントの基本的な設計 覚えやすく、どんな機能を持つURIなのかがひと目でわかる  短くて入力しやすいURI 人間が読んで理解できるURL 大文字小文字が混在していないURI 改造しやすい（Hackableな）URI サーバー側のアーキテクチャが反映されていないURI  どんなソフトウェア、言語を利用しているのか。 ディレクトリやシステム構成がどうなっているのか。   ルールが統一されたURI  リソースにアクセスするための設計の注意点  複数形の名詞を利用する 利用する単語に気をつける スペースやエンコードを必要とする文字を使わない 単語をつなげる必要がある場合はハイフンを利用する  リソースの一覧取得のエンドポイントが検索を兼ねる。 絞り込み検索はパラメーターを設定する。\n検索に相対位置を利用する問題点 データ数が膨大になるとpageやoffsetを指定されていると「先頭から何件目か」を調べるために先頭から数を数える処理が行われるため遅くなる。 また、更新頻度が高いデータの場合データに不整合が生じる。\n絶対位置でデータを問題点 絶対位置指定とは、オフセットで相対位置を指定する代わりに、これまで取得した最後のデータのIDや時間を記録しておいて、「このIDより前のもの」や「この時刻より古いもの」と言った指定を行う方法。　配列とフォーマット オブジェクトで配列を包むメリット  レスポンスデータが何をしていものかがわかりやすくなる レスポンスデータをオブジェクトに統一することができる。 セキュリティ上のリスクを避けることができる  トップれべるが配列であるJSONは、JSONインジェクションに対するリスクが大きくなる。\n続きがある場合どうデータを返すべきか 例えば20件データを返すためには最大21件の取得を行ってみて、実際に21件取得できれば、 「hasNext」といった名前で結果を含めてあげれば良い。","title":"APIの設計"},{"content":"DRFでオブジェクトを作成したとき、 デフォルトで、 作成したオブジェクトを含むディクショナリー型でデータを返す。\nkeys() Pythonの組み込み関数。\nkeys() dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} print(dict.keys()) \u0026gt;\u0026gt;\u0026gt;dict_keys([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} for key in dict.keys(): print(key) \u0026gt;\u0026gt;\u0026gt;A \u0026gt;\u0026gt;\u0026gt;B \u0026gt;\u0026gt;\u0026gt;C getattr Pythonの組み込み関数。\ngetattr(object, name[,default]) 第一引数に指定された object の値を返す。 第二引数の name は文字列である必要があり、文字列が object の属性の一つの名前であった場合、戻り値はその属性の値になる。\nquery_params request.GETと同義語。\nDRF では query_params を使用することを推奨。\nDRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-08/","summary":"DRFでオブジェクトを作成したとき、 デフォルトで、 作成したオブジェクトを含むディクショナリー型でデータを返す。\nkeys() Pythonの組み込み関数。\nkeys() dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} print(dict.keys()) \u0026gt;\u0026gt;\u0026gt;dict_keys([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} for key in dict.keys(): print(key) \u0026gt;\u0026gt;\u0026gt;A \u0026gt;\u0026gt;\u0026gt;B \u0026gt;\u0026gt;\u0026gt;C getattr Pythonの組み込み関数。\ngetattr(object, name[,default]) 第一引数に指定された object の値を返す。 第二引数の name は文字列である必要があり、文字列が object の属性の一つの名前であった場合、戻り値はその属性の値になる。\nquery_params request.GETと同義語。\nDRF では query_params を使用することを推奨。\nDRF ドキュメント","title":"2021 07 08"},{"content":"APIClient APIClientは Djang の Clientクラスを拡張したもの .get()、.post()、.put()、.pathch()、.delete()、.head()、.options()が利用可能。\n例\nfrom rest_framework.test import APIClient client = APIClient() client.post('/notes/', {'title': 'new idea'}, format='json') status from rest_framework import status 人間が読むことができるステータスコードを含む。 テストの際に理解が簡単 github\nrefresh_from_db() モデルのバリューをリフレッシュ使うのに使用。 このメソッドが引数なしで呼ばれると\n モデル上の遅延評価されない全てのフィールドはその時点でデータベース上に存在する値に更新されます。 キャッシュされたリレーションはリロードされたインスタンスに削除される。 Django ドキュメント  force_authenticate() テストする際に強制的に認証をリクエストする\nforce_authenticate(request, user=None, token=None)が呼ばれる時 user か token のいずれか、または両方を設定できる。\nGenericViewSet GenericViewSet クラスは GenericAPIView の継承し、get_object、get_queryset を提供し、デフォルトでは\nGenericViewSetクラスを使用するには、クラスをオーバーライドして、必要なmixinクラスをミックスインするか、アクションの実装を明示的に定義します。\nDRF ドキュメント\nModelSerializer ModelSerializerクラスはSerializer  class とモデルの一致するフィールドを自動で作成する\nModelSerializer クラスは Serializer と同じだが、 *モデルを基にフィールドを自動で作成する *unique_together のようなserializerのためのvalidatorを自動で作成する *デフォルトで .create() .update() 含む。\nmany=True Serializer クラスは serializing もしくは deserializing のリストオブジェクトを扱える。\nserialize する際に many=True を使うことで、queryset もしくはオブジェクトリストをserialize することが出来る。\nperform_create perform_create(self, serializer) は CreateModelMixinが呼ばれたときに新しいオブジェクトを保存する。\nPrimaryKeyRelatedField 例\nclass AlbumSerializer(serializers.ModelSerializer): tracks = serializers.PrimaryKeyRelatedField(many=True, read_only=True) class Meta: model = Album fields = ['album_name', 'artist', 'tracks'] { 'album_name': 'Undun', 'artist': 'The Roots', 'tracks': [ 89, 90, 91, ... ] } DRF ドキュメント\nModelViewSet ModelViewSet クラスは GenericAPIViewを継承。\nModelViewSet クラスは .list(), .retrieve(), .create(), .update(), partial_update(), .destroy()\nDRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/django-rest-framework/","summary":"APIClient APIClientは Djang の Clientクラスを拡張したもの .get()、.post()、.put()、.pathch()、.delete()、.head()、.options()が利用可能。\n例\nfrom rest_framework.test import APIClient client = APIClient() client.post('/notes/', {'title': 'new idea'}, format='json') status from rest_framework import status 人間が読むことができるステータスコードを含む。 テストの際に理解が簡単 github\nrefresh_from_db() モデルのバリューをリフレッシュ使うのに使用。 このメソッドが引数なしで呼ばれると\n モデル上の遅延評価されない全てのフィールドはその時点でデータベース上に存在する値に更新されます。 キャッシュされたリレーションはリロードされたインスタンスに削除される。 Django ドキュメント  force_authenticate() テストする際に強制的に認証をリクエストする\nforce_authenticate(request, user=None, token=None)が呼ばれる時 user か token のいずれか、または両方を設定できる。\nGenericViewSet GenericViewSet クラスは GenericAPIView の継承し、get_object、get_queryset を提供し、デフォルトでは\nGenericViewSetクラスを使用するには、クラスをオーバーライドして、必要なmixinクラスをミックスインするか、アクションの実装を明示的に定義します。\nDRF ドキュメント\nModelSerializer ModelSerializerクラスはSerializer  class とモデルの一致するフィールドを自動で作成する\nModelSerializer クラスは Serializer と同じだが、 *モデルを基にフィールドを自動で作成する *unique_together のようなserializerのためのvalidatorを自動で作成する *デフォルトで .create() .update() 含む。","title":"Django Rest Framework"},{"content":"公開したいページのあるリポジトリの Settings をクリック。\nサイドナビの　Pages をクリック。\n公開したいブランチを選択\n事前にCNAMEでドメインを設定しておいて\n設定したドメインを適用\n","permalink":"https://hirotoshimizu.github.io/posts/host-a-website-on-github/","summary":"公開したいページのあるリポジトリの Settings をクリック。\nサイドナビの　Pages をクリック。\n公開したいブランチを選択\n事前にCNAMEでドメインを設定しておいて\n設定したドメインを適用","title":"GitHub Pages で静的サイトの公開方法"},{"content":"日々学んだ事を記録に残そうと始めました。\nWord Press や Django でブログを作成しようと思いましたが、\n速度やメンテナンスを楽にしたかったので、Hugoで作成。\n設定環境\n Win 10 WSL2 Ubuntu 20.04  1. Hugoのインストール Ubuntuでのインストール\nsudo apt-get install hugo 2. サイトの作成 hugo new site sitename sitename は自分の好きな名前に置き換えてください。\n3. テーマの追加 Hugo のテーマ から好きなテンプレートを選択。\nPaperMod を選択したので、 インストラクションに沿ってgit clone\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. コンテンツの追加 hugo new posts/my-first-post.md --- title: \u0026quot;My First Post\u0026quot; date: 2019-03-26T08:47:11+01:00 draft: true --- ※draft: false に変更で公開\n5. Hugo server を起動 hugo server ","permalink":"https://hirotoshimizu.github.io/posts/how-to-start-hugo/","summary":"日々学んだ事を記録に残そうと始めました。\nWord Press や Django でブログを作成しようと思いましたが、\n速度やメンテナンスを楽にしたかったので、Hugoで作成。\n設定環境\n Win 10 WSL2 Ubuntu 20.04  1. Hugoのインストール Ubuntuでのインストール\nsudo apt-get install hugo 2. サイトの作成 hugo new site sitename sitename は自分の好きな名前に置き換えてください。\n3. テーマの追加 Hugo のテーマ から好きなテンプレートを選択。\nPaperMod を選択したので、 インストラクションに沿ってgit clone\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. コンテンツの追加 hugo new posts/my-first-post.md --- title: \u0026quot;My First Post\u0026quot; date: 2019-03-26T08:47:11+01:00 draft: true --- ※draft: false に変更で公開\n5. Hugo server を起動 hugo server ","title":"Hugo の始め方"},{"content":"このサイトは日々学んだことをメモするためのサイトです。\n","permalink":"https://hirotoshimizu.github.io/about/","summary":"about","title":"about"},{"content":"","permalink":"https://hirotoshimizu.github.io/search/","summary":"search","title":"Search"}]