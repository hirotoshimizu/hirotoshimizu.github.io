[{"content":"PrimaryKeyRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのプライマリーキーを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.PrimaryKeyRelatedField(source=\u0026#39;user\u0026#39;, read_only=True) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: 1, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.HyperlinkedRelatedField( source=\u0026#39;user\u0026#39;, # user foreign key lookup_field=\u0026#39;username\u0026#39;, view_name=\u0026#39;api-user:detail\u0026#39;, read_only=True ) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;] view_name  lookup_field リレーション関係にあるターゲット上のフィールド。 参照する view の URL キーワード引数と一致する必要がある。 デフォルトではpk\n \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot;, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user_id = serializers.HyperlinkedRelatedField( source=\u0026#39;user\u0026#39;, # user foreign key lookup_field=\u0026#39;username\u0026#39;, view_name=\u0026#39;api-user:detail\u0026#39;, read_only=True ) user = serializers.SlugRelatedField(read_only=True, slug_field=\u0026#39;username\u0026#39;) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/7/\u0026quot;, \u0026quot;user_id\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/hshimizu/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user\u0026quot;: \u0026quot;hshimizu\u0026quot;, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/hshimizu/images.png\u0026quot; }, DRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-14/","summary":"PrimaryKeyRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのプライマリーキーを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.PrimaryKeyRelatedField(source=\u0026#39;user\u0026#39;, read_only=True) class Meta: model = Status fields = [ \u0026#39;uri\u0026#39;, \u0026#39;user_id\u0026#39;, \u0026#39;id\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;image\u0026#39; ] read_only_fields = [\u0026#39;user\u0026#39;]  \u0026quot;results\u0026quot;: [ { \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/status/1/\u0026quot;, \u0026quot;id\u0026quot;: 7, \u0026quot;user_id\u0026quot;: 1, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://127.0.0.1:8000/api/user/test/\u0026quot; }, \u0026quot;content\u0026quot;: \u0026quot;do some stuff here\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;http://127.0.0.1:8000/media/status/test/images.png\u0026quot; }, DRF ドキュメント\nHyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。\nclass StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.","title":"2021 07 13"},{"content":"Authenticating users authenticate(request=None, **credentials)\nauthenticate() は認証の承認のために使用する関数。 デフォルトでは keyword arguments で username と password で認証し、 User オブジェクトを返す。\nset_password(raw_password)\nパスワードをハッシュ化するのに使う。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-12/","summary":"Authenticating users authenticate(request=None, **credentials)\nauthenticate() は認証の承認のために使用する関数。 デフォルトでは keyword arguments で username と password で認証し、 User オブジェクトを返す。\nset_password(raw_password)\nパスワードをハッシュ化するのに使う。","title":"2021 07 12"},{"content":"python での JSON の扱いについてわすれるのでメモ。\njson.dumps json.dumps()に入れた変数を JSON string に変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' json.loads json.loads(JSON string) で python dictionary に型を変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' \u0026gt;\u0026gt;\u0026gt; load_json = json.loads(data_json) \u0026gt;\u0026gt;\u0026gt; load_json {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(load_json) \u0026lt;class 'dict'\u0026gt; \u0026gt;\u0026gt;\u0026gt; load_json['abc'] 123 Django Rest Framework\nSerializerでの Create, Update, Delete \u0026quot;\u0026rdquo;\u0026rdquo; Create obj \u0026quot;\u0026rdquo;\u0026rdquo;\ndata = {'user': 1} serializer = StatusSerializer(data=data) serializer.is_valid() # is_validでデータを検証しないと .save() でエラーが出る serializer.save() \u0026quot;\u0026rdquo;\u0026rdquo; Update obj \u0026quot;\u0026rdquo;\u0026rdquo;\nobj = Status.objects.first() data = {'content': 'some new content', 'user': 1} update_serializer = StatusSerializer(obj, data=data) update_serializer.is_valid() update_serializer.save update_serializer.errors {'user': ['This field is required.']} \u0026quot;\u0026rdquo;\u0026rdquo; Delete obj \u0026quot;\u0026rdquo;\u0026rdquo;\nobj = Status.objects.last() obj.delete() Delete は Serializerを使わず、objectを取得して削除。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-11/","summary":"python での JSON の扱いについてわすれるのでメモ。\njson.dumps json.dumps()に入れた変数を JSON string に変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' json.loads json.loads(JSON string) で python dictionary に型を変換する。\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(data_json) \u0026lt;class 'str'\u0026gt; \u0026gt;\u0026gt;\u0026gt; data_json = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; data_json '{\u0026quot;abc\u0026quot;: 123}' \u0026gt;\u0026gt;\u0026gt; load_json = json.loads(data_json) \u0026gt;\u0026gt;\u0026gt; load_json {'abc': 123} \u0026gt;\u0026gt;\u0026gt; type(load_json) \u0026lt;class 'dict'\u0026gt; \u0026gt;\u0026gt;\u0026gt; load_json['abc'] 123 Django Rest Framework","title":"2021 07 11"},{"content":"Web API the good parts\nエンドポイントの基本的な設計 覚えやすく、どんな機能を持つURIなのかがひと目でわかる  短くて入力しやすいURI 人間が読んで理解できるURL 大文字小文字が混在していないURI 改造しやすい（Hackableな）URI サーバー側のアーキテクチャが反映されていないURI  どんなソフトウェア、言語を利用しているのか。 ディレクトリやシステム構成がどうなっているのか。   ルールが統一されたURI  リソースにアクセスするための設計の注意点  複数形の名詞を利用する 利用する単語に気をつける スペースやエンコードを必要とする文字を使わない 単語をつなげる必要がある場合はハイフンを利用する  リソースの一覧取得のエンドポイントが検索を兼ねる。 絞り込み検索はパラメーターを設定する。\n検索に相対位置を利用する問題点 データ数が膨大になるとpageやoffsetを指定されていると「先頭から何件目か」を調べるために先頭から数を数える処理が行われるため遅くなる。 また、更新頻度が高いデータの場合データに不整合が生じる。\n絶対位置でデータを問題点 絶対位置指定とは、オフセットで相対位置を指定する代わりに、これまで取得した最後のデータのIDや時間を記録しておいて、「このIDより前のもの」や「この時刻より古いもの」と言った指定を行う方法。　配列とフォーマット オブジェクトで配列を包むメリット  レスポンスデータが何をしていものかがわかりやすくなる レスポンスデータをオブジェクトに統一することができる。 セキュリティ上のリスクを避けることができる  トップれべるが配列であるJSONは、JSONインジェクションに対するリスクが大きくなる。\n続きがある場合どうデータを返すべきか 例えば20件データを返すためには最大21件の取得を行ってみて、実際に21件取得できれば、 「hasNext」といった名前で結果を含めてあげれば良い。\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-09/","summary":"Web API the good parts\nエンドポイントの基本的な設計 覚えやすく、どんな機能を持つURIなのかがひと目でわかる  短くて入力しやすいURI 人間が読んで理解できるURL 大文字小文字が混在していないURI 改造しやすい（Hackableな）URI サーバー側のアーキテクチャが反映されていないURI  どんなソフトウェア、言語を利用しているのか。 ディレクトリやシステム構成がどうなっているのか。   ルールが統一されたURI  リソースにアクセスするための設計の注意点  複数形の名詞を利用する 利用する単語に気をつける スペースやエンコードを必要とする文字を使わない 単語をつなげる必要がある場合はハイフンを利用する  リソースの一覧取得のエンドポイントが検索を兼ねる。 絞り込み検索はパラメーターを設定する。\n検索に相対位置を利用する問題点 データ数が膨大になるとpageやoffsetを指定されていると「先頭から何件目か」を調べるために先頭から数を数える処理が行われるため遅くなる。 また、更新頻度が高いデータの場合データに不整合が生じる。\n絶対位置でデータを問題点 絶対位置指定とは、オフセットで相対位置を指定する代わりに、これまで取得した最後のデータのIDや時間を記録しておいて、「このIDより前のもの」や「この時刻より古いもの」と言った指定を行う方法。　配列とフォーマット オブジェクトで配列を包むメリット  レスポンスデータが何をしていものかがわかりやすくなる レスポンスデータをオブジェクトに統一することができる。 セキュリティ上のリスクを避けることができる  トップれべるが配列であるJSONは、JSONインジェクションに対するリスクが大きくなる。\n続きがある場合どうデータを返すべきか 例えば20件データを返すためには最大21件の取得を行ってみて、実際に21件取得できれば、 「hasNext」といった名前で結果を含めてあげれば良い。","title":"APIの設計"},{"content":"DRFでオブジェクトを作成したとき、 デフォルトで、 作成したオブジェクトを含むディクショナリー型でデータを返す。\nkeys() Pythonの組み込み関数。\nkeys() dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} print(dict.keys()) \u0026gt;\u0026gt;\u0026gt;dict_keys([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} for key in dict.keys(): print(key) \u0026gt;\u0026gt;\u0026gt;A \u0026gt;\u0026gt;\u0026gt;B \u0026gt;\u0026gt;\u0026gt;C getattr Pythonの組み込み関数。\ngetattr(object, name[,default]) 第一引数に指定された object の値を返す。 第二引数の name は文字列である必要があり、文字列が object の属性の一つの名前であった場合、戻り値はその属性の値になる。\nquery_params request.GETと同義語。\nDRF では query_params を使用することを推奨。\nDRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/2021-07-08/","summary":"DRFでオブジェクトを作成したとき、 デフォルトで、 作成したオブジェクトを含むディクショナリー型でデータを返す。\nkeys() Pythonの組み込み関数。\nkeys() dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} print(dict.keys()) \u0026gt;\u0026gt;\u0026gt;dict_keys([\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]) dict = {\u0026#34;A\u0026#34;: \u0026#34;Abalone\u0026#34;, \u0026#34;B\u0026#34;: \u0026#34;bluefin tuna\u0026#34;, \u0026#34;C\u0026#34;: \u0026#34;cod\u0026#34;} for key in dict.keys(): print(key) \u0026gt;\u0026gt;\u0026gt;A \u0026gt;\u0026gt;\u0026gt;B \u0026gt;\u0026gt;\u0026gt;C getattr Pythonの組み込み関数。\ngetattr(object, name[,default]) 第一引数に指定された object の値を返す。 第二引数の name は文字列である必要があり、文字列が object の属性の一つの名前であった場合、戻り値はその属性の値になる。\nquery_params request.GETと同義語。\nDRF では query_params を使用することを推奨。\nDRF ドキュメント","title":"2021 07 08"},{"content":"APIClient APIClientは Djang の Clientクラスを拡張したもの .get()、.post()、.put()、.pathch()、.delete()、.head()、.options()が利用可能。\n例\nfrom rest_framework.test import APIClient client = APIClient() client.post('/notes/', {'title': 'new idea'}, format='json') status from rest_framework import status 人間が読むことができるステータスコードを含む。 テストの際に理解が簡単 github\nrefresh_from_db() モデルのバリューをリフレッシュ使うのに使用。 このメソッドが引数なしで呼ばれると\n モデル上の遅延評価されない全てのフィールドはその時点でデータベース上に存在する値に更新されます。 キャッシュされたリレーションはリロードされたインスタンスに削除される。 Django ドキュメント  force_authenticate() テストする際に強制的に認証をリクエストする\nforce_authenticate(request, user=None, token=None)が呼ばれる時 user か token のいずれか、または両方を設定できる。\nGenericViewSet GenericViewSet クラスは GenericAPIView の継承し、get_object、get_queryset を提供し、デフォルトでは\nGenericViewSetクラスを使用するには、クラスをオーバーライドして、必要なmixinクラスをミックスインするか、アクションの実装を明示的に定義します。\nDRF ドキュメント\nModelSerializer ModelSerializerクラスはSerializer  class とモデルの一致するフィールドを自動で作成する\nModelSerializer クラスは Serializer と同じだが、 *モデルを基にフィールドを自動で作成する *unique_together のようなserializerのためのvalidatorを自動で作成する *デフォルトで .create() .update() 含む。\nmany=True Serializer クラスは serializing もしくは deserializing のリストオブジェクトを扱える。\nserialize する際に many=True を使うことで、queryset もしくはオブジェクトリストをserialize することが出来る。\nperform_create perform_create(self, serializer) は CreateModelMixinが呼ばれたときに新しいオブジェクトを保存する。\nPrimaryKeyRelatedField 例\nclass AlbumSerializer(serializers.ModelSerializer): tracks = serializers.PrimaryKeyRelatedField(many=True, read_only=True) class Meta: model = Album fields = ['album_name', 'artist', 'tracks'] { 'album_name': 'Undun', 'artist': 'The Roots', 'tracks': [ 89, 90, 91, ... ] } DRF ドキュメント\nModelViewSet ModelViewSet クラスは GenericAPIViewを継承。\nModelViewSet クラスは .list(), .retrieve(), .create(), .update(), partial_update(), .destroy()\nDRF ドキュメント\n","permalink":"https://hirotoshimizu.github.io/posts/django-rest-framework/","summary":"APIClient APIClientは Djang の Clientクラスを拡張したもの .get()、.post()、.put()、.pathch()、.delete()、.head()、.options()が利用可能。\n例\nfrom rest_framework.test import APIClient client = APIClient() client.post('/notes/', {'title': 'new idea'}, format='json') status from rest_framework import status 人間が読むことができるステータスコードを含む。 テストの際に理解が簡単 github\nrefresh_from_db() モデルのバリューをリフレッシュ使うのに使用。 このメソッドが引数なしで呼ばれると\n モデル上の遅延評価されない全てのフィールドはその時点でデータベース上に存在する値に更新されます。 キャッシュされたリレーションはリロードされたインスタンスに削除される。 Django ドキュメント  force_authenticate() テストする際に強制的に認証をリクエストする\nforce_authenticate(request, user=None, token=None)が呼ばれる時 user か token のいずれか、または両方を設定できる。\nGenericViewSet GenericViewSet クラスは GenericAPIView の継承し、get_object、get_queryset を提供し、デフォルトでは\nGenericViewSetクラスを使用するには、クラスをオーバーライドして、必要なmixinクラスをミックスインするか、アクションの実装を明示的に定義します。\nDRF ドキュメント\nModelSerializer ModelSerializerクラスはSerializer  class とモデルの一致するフィールドを自動で作成する\nModelSerializer クラスは Serializer と同じだが、 *モデルを基にフィールドを自動で作成する *unique_together のようなserializerのためのvalidatorを自動で作成する *デフォルトで .create() .update() 含む。","title":"Django Rest Framework"},{"content":"公開したいページのあるリポジトリの Settings をクリック。\nサイドナビの　Pages をクリック。\n公開したいブランチを選択\n事前にCNAMEでドメインを設定しておいて\n設定したドメインを適用\n","permalink":"https://hirotoshimizu.github.io/posts/host-a-website-on-github/","summary":"公開したいページのあるリポジトリの Settings をクリック。\nサイドナビの　Pages をクリック。\n公開したいブランチを選択\n事前にCNAMEでドメインを設定しておいて\n設定したドメインを適用","title":"GitHub Pages で静的サイトの公開方法"},{"content":"日々学んだ事を記録に残そうと始めました。\nWord Press や Django でブログを作成しようと思いましたが、\n速度やメンテナンスを楽にしたかったので、Hugoで作成。\n設定環境\n Win 10 WSL2 Ubuntu 20.04  1. Hugoのインストール Ubuntuでのインストール\nsudo apt-get install hugo 2. サイトの作成 hugo new site sitename sitename は自分の好きな名前に置き換えてください。\n3. テーマの追加 Hugo のテーマ から好きなテンプレートを選択。\nPaperMod を選択したので、 インストラクションに沿ってgit clone\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. コンテンツの追加 hugo new posts/my-first-post.md --- title: \u0026quot;My First Post\u0026quot; date: 2019-03-26T08:47:11+01:00 draft: true --- ※draft: false に変更で公開\n5. Hugo server を起動 hugo server ","permalink":"https://hirotoshimizu.github.io/posts/how-to-start-hugo/","summary":"日々学んだ事を記録に残そうと始めました。\nWord Press や Django でブログを作成しようと思いましたが、\n速度やメンテナンスを楽にしたかったので、Hugoで作成。\n設定環境\n Win 10 WSL2 Ubuntu 20.04  1. Hugoのインストール Ubuntuでのインストール\nsudo apt-get install hugo 2. サイトの作成 hugo new site sitename sitename は自分の好きな名前に置き換えてください。\n3. テーマの追加 Hugo のテーマ から好きなテンプレートを選択。\nPaperMod を選択したので、 インストラクションに沿ってgit clone\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. コンテンツの追加 hugo new posts/my-first-post.md --- title: \u0026quot;My First Post\u0026quot; date: 2019-03-26T08:47:11+01:00 draft: true --- ※draft: false に変更で公開\n5. Hugo server を起動 hugo server ","title":"Hugo の始め方"},{"content":"このサイトは日々学んだことをメモするためのサイトです。\n","permalink":"https://hirotoshimizu.github.io/about/","summary":"about","title":"about"},{"content":"","permalink":"https://hirotoshimizu.github.io/search/","summary":"search","title":"Search"}]