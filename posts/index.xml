<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Shiglass</title>
    <link>https://hirotoshimizu.github.io/posts/</link>
    <description>Recent content in Posts on Shiglass</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 13 Jul 2021 23:32:01 +0900</lastBuildDate><atom:link href="https://hirotoshimizu.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2021 07 13</title>
      <link>https://hirotoshimizu.github.io/posts/2021-07-14/</link>
      <pubDate>Tue, 13 Jul 2021 23:32:01 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/2021-07-14/</guid>
      <description>PrimaryKeyRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのプライマリーキーを取得することが出来る。
class StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.PrimaryKeyRelatedField(source=&amp;#39;user&amp;#39;, read_only=True) class Meta: model = Status fields = [ &amp;#39;uri&amp;#39;, &amp;#39;user_id&amp;#39;, &amp;#39;id&amp;#39;, &amp;#39;user&amp;#39;, &amp;#39;content&amp;#39;, &amp;#39;image&amp;#39; ] read_only_fields = [&amp;#39;user&amp;#39;]  &amp;quot;results&amp;quot;: [ { &amp;quot;uri&amp;quot;: &amp;quot;http://127.0.0.1:8000/api/status/1/&amp;quot;, &amp;quot;id&amp;quot;: 7, &amp;quot;user_id&amp;quot;: 1, &amp;quot;user&amp;quot;: { &amp;quot;id&amp;quot;: 1, &amp;quot;username&amp;quot;: &amp;quot;test&amp;quot;, &amp;quot;uri&amp;quot;: &amp;quot;http://127.0.0.1:8000/api/user/test/&amp;quot; }, &amp;quot;content&amp;quot;: &amp;quot;do some stuff here&amp;quot;, &amp;quot;image&amp;quot;: &amp;quot;http://127.0.0.1:8000/media/status/test/images.png&amp;quot; }, DRF ドキュメント
HyperlinkedRelatedField PrimaryKeyRelatedField を使用することでリレーションのあるテーブルのターゲットのハイパーリンクを取得することが出来る。
class StatusSerializer(serializers.ModelSerializer): uri = serializers.SerializerMethodField(read_only=True) user = UserPublicSerializer(read_only=True) user_id = serializers.</description>
    </item>
    
    <item>
      <title>2021 07 12</title>
      <link>https://hirotoshimizu.github.io/posts/2021-07-12/</link>
      <pubDate>Sun, 11 Jul 2021 06:49:02 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/2021-07-12/</guid>
      <description>Authenticating users authenticate(request=None, **credentials)
authenticate() は認証の承認のために使用する関数。 デフォルトでは keyword arguments で username と password で認証し、 User オブジェクトを返す。
set_password(raw_password)
パスワードをハッシュ化するのに使う。</description>
    </item>
    
    <item>
      <title>2021 07 11</title>
      <link>https://hirotoshimizu.github.io/posts/2021-07-11/</link>
      <pubDate>Fri, 09 Jul 2021 23:37:25 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/2021-07-11/</guid>
      <description>python での JSON の扱いについてわすれるのでメモ。
json.dumps json.dumps()に入れた変数を JSON string に変換する。
&amp;gt;&amp;gt;&amp;gt; import json &amp;gt;&amp;gt;&amp;gt; data = {&#39;abc&#39;: 123} &amp;gt;&amp;gt;&amp;gt; type(data_json) &amp;lt;class &#39;str&#39;&amp;gt; &amp;gt;&amp;gt;&amp;gt; data_json = json.dumps(data) &amp;gt;&amp;gt;&amp;gt; data_json &#39;{&amp;quot;abc&amp;quot;: 123}&#39; json.loads json.loads(JSON string) で python dictionary に型を変換する。
&amp;gt;&amp;gt;&amp;gt; import json &amp;gt;&amp;gt;&amp;gt; data = {&#39;abc&#39;: 123} &amp;gt;&amp;gt;&amp;gt; type(data_json) &amp;lt;class &#39;str&#39;&amp;gt; &amp;gt;&amp;gt;&amp;gt; data_json = json.dumps(data) &amp;gt;&amp;gt;&amp;gt; data_json &#39;{&amp;quot;abc&amp;quot;: 123}&#39; &amp;gt;&amp;gt;&amp;gt; load_json = json.loads(data_json) &amp;gt;&amp;gt;&amp;gt; load_json {&#39;abc&#39;: 123} &amp;gt;&amp;gt;&amp;gt; type(load_json) &amp;lt;class &#39;dict&#39;&amp;gt; &amp;gt;&amp;gt;&amp;gt; load_json[&#39;abc&#39;] 123 Django Rest Framework</description>
    </item>
    
    <item>
      <title>APIの設計</title>
      <link>https://hirotoshimizu.github.io/posts/2021-07-09/</link>
      <pubDate>Fri, 09 Jul 2021 03:03:25 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/2021-07-09/</guid>
      <description>Web API the good parts
エンドポイントの基本的な設計 覚えやすく、どんな機能を持つURIなのかがひと目でわかる  短くて入力しやすいURI 人間が読んで理解できるURL 大文字小文字が混在していないURI 改造しやすい（Hackableな）URI サーバー側のアーキテクチャが反映されていないURI  どんなソフトウェア、言語を利用しているのか。 ディレクトリやシステム構成がどうなっているのか。   ルールが統一されたURI  リソースにアクセスするための設計の注意点  複数形の名詞を利用する 利用する単語に気をつける スペースやエンコードを必要とする文字を使わない 単語をつなげる必要がある場合はハイフンを利用する  リソースの一覧取得のエンドポイントが検索を兼ねる。 絞り込み検索はパラメーターを設定する。
検索に相対位置を利用する問題点 データ数が膨大になるとpageやoffsetを指定されていると「先頭から何件目か」を調べるために先頭から数を数える処理が行われるため遅くなる。 また、更新頻度が高いデータの場合データに不整合が生じる。
絶対位置でデータを問題点 絶対位置指定とは、オフセットで相対位置を指定する代わりに、これまで取得した最後のデータのIDや時間を記録しておいて、「このIDより前のもの」や「この時刻より古いもの」と言った指定を行う方法。　配列とフォーマット オブジェクトで配列を包むメリット  レスポンスデータが何をしていものかがわかりやすくなる レスポンスデータをオブジェクトに統一することができる。 セキュリティ上のリスクを避けることができる  トップれべるが配列であるJSONは、JSONインジェクションに対するリスクが大きくなる。
続きがある場合どうデータを返すべきか 例えば20件データを返すためには最大21件の取得を行ってみて、実際に21件取得できれば、 「hasNext」といった名前で結果を含めてあげれば良い。</description>
    </item>
    
    <item>
      <title>2021 07 08</title>
      <link>https://hirotoshimizu.github.io/posts/2021-07-08/</link>
      <pubDate>Thu, 08 Jul 2021 08:04:28 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/2021-07-08/</guid>
      <description>DRFでオブジェクトを作成したとき、 デフォルトで、 作成したオブジェクトを含むディクショナリー型でデータを返す。
keys() Pythonの組み込み関数。
keys() dict = {&amp;#34;A&amp;#34;: &amp;#34;Abalone&amp;#34;, &amp;#34;B&amp;#34;: &amp;#34;bluefin tuna&amp;#34;, &amp;#34;C&amp;#34;: &amp;#34;cod&amp;#34;} print(dict.keys()) &amp;gt;&amp;gt;&amp;gt;dict_keys([&amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;]) dict = {&amp;#34;A&amp;#34;: &amp;#34;Abalone&amp;#34;, &amp;#34;B&amp;#34;: &amp;#34;bluefin tuna&amp;#34;, &amp;#34;C&amp;#34;: &amp;#34;cod&amp;#34;} for key in dict.keys(): print(key) &amp;gt;&amp;gt;&amp;gt;A &amp;gt;&amp;gt;&amp;gt;B &amp;gt;&amp;gt;&amp;gt;C getattr Pythonの組み込み関数。
getattr(object, name[,default]) 第一引数に指定された object の値を返す。 第二引数の name は文字列である必要があり、文字列が object の属性の一つの名前であった場合、戻り値はその属性の値になる。
query_params request.GETと同義語。
DRF では query_params を使用することを推奨。
DRF ドキュメント</description>
    </item>
    
    <item>
      <title>Django Rest Framework</title>
      <link>https://hirotoshimizu.github.io/posts/django-rest-framework/</link>
      <pubDate>Wed, 07 Jul 2021 11:51:51 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/django-rest-framework/</guid>
      <description>APIClient APIClientは Djang の Clientクラスを拡張したもの .get()、.post()、.put()、.pathch()、.delete()、.head()、.options()が利用可能。
例
from rest_framework.test import APIClient client = APIClient() client.post(&#39;/notes/&#39;, {&#39;title&#39;: &#39;new idea&#39;}, format=&#39;json&#39;) status from rest_framework import status 人間が読むことができるステータスコードを含む。 テストの際に理解が簡単 github
refresh_from_db() モデルのバリューをリフレッシュ使うのに使用。 このメソッドが引数なしで呼ばれると
 モデル上の遅延評価されない全てのフィールドはその時点でデータベース上に存在する値に更新されます。 キャッシュされたリレーションはリロードされたインスタンスに削除される。 Django ドキュメント  force_authenticate() テストする際に強制的に認証をリクエストする
force_authenticate(request, user=None, token=None)が呼ばれる時 user か token のいずれか、または両方を設定できる。
GenericViewSet GenericViewSet クラスは GenericAPIView の継承し、get_object、get_queryset を提供し、デフォルトでは
GenericViewSetクラスを使用するには、クラスをオーバーライドして、必要なmixinクラスをミックスインするか、アクションの実装を明示的に定義します。
DRF ドキュメント
ModelSerializer ModelSerializerクラスはSerializer  class とモデルの一致するフィールドを自動で作成する
ModelSerializer クラスは Serializer と同じだが、 *モデルを基にフィールドを自動で作成する *unique_together のようなserializerのためのvalidatorを自動で作成する *デフォルトで .create() .update() 含む。</description>
    </item>
    
    <item>
      <title>GitHub Pages で静的サイトの公開方法</title>
      <link>https://hirotoshimizu.github.io/posts/host-a-website-on-github/</link>
      <pubDate>Tue, 06 Jul 2021 08:50:31 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/host-a-website-on-github/</guid>
      <description>公開したいページのあるリポジトリの Settings をクリック。
サイドナビの　Pages をクリック。
公開したいブランチを選択
事前にCNAMEでドメインを設定しておいて
設定したドメインを適用</description>
    </item>
    
    <item>
      <title>Hugo の始め方</title>
      <link>https://hirotoshimizu.github.io/posts/how-to-start-hugo/</link>
      <pubDate>Mon, 05 Jul 2021 16:02:47 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/how-to-start-hugo/</guid>
      <description>日々学んだ事を記録に残そうと始めました。
Word Press や Django でブログを作成しようと思いましたが、
速度やメンテナンスを楽にしたかったので、Hugoで作成。
設定環境
 Win 10 WSL2 Ubuntu 20.04  1. Hugoのインストール Ubuntuでのインストール
sudo apt-get install hugo 2. サイトの作成 hugo new site sitename sitename は自分の好きな名前に置き換えてください。
3. テーマの追加 Hugo のテーマ から好きなテンプレートを選択。
PaperMod を選択したので、 インストラクションに沿ってgit clone
git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. コンテンツの追加 hugo new posts/my-first-post.md --- title: &amp;quot;My First Post&amp;quot; date: 2019-03-26T08:47:11+01:00 draft: true --- ※draft: false に変更で公開
5. Hugo server を起動 hugo server </description>
    </item>
    
  </channel>
</rss>
