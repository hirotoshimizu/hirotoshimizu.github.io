<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Refactoring on Shiglass</title>
    <link>https://hirotoshimizu.github.io/tags/refactoring/</link>
    <description>Recent content in Refactoring on Shiglass</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 18 Feb 2022 18:26:32 +0900</lastBuildDate><atom:link href="https://hirotoshimizu.github.io/tags/refactoring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dependency Inversion Principle</title>
      <link>https://hirotoshimizu.github.io/posts/dependency-inversion-principle/</link>
      <pubDate>Fri, 18 Feb 2022 18:26:32 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/dependency-inversion-principle/</guid>
      <description>ソースコードの依存関係が（具象ではなく）抽象だけを参照しているシステムが最も柔軟である。
Before from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = &amp;#39;open&amp;#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class Authorizer(ABC): @abstractmethod def is_authorized(self) -&amp;gt; bool: pass class Authorizer_SMS(Authorizer): def __init__(self): self.authorized = False def verify_code(self, code): print(f&amp;#39;Verifying SMS code {code}&amp;#39;) self.authorized = True def is_authorized(self) -&amp;gt; bool: return self.</description>
    </item>
    
    <item>
      <title>Interface Segregation Principle</title>
      <link>https://hirotoshimizu.github.io/posts/interface-segregation-principle/</link>
      <pubDate>Fri, 18 Feb 2022 14:09:01 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/interface-segregation-principle/</guid>
      <description>包括的なインターフェースがあるより、いくつかの特定のインターフェースに分割すべき。
Before from abc import ABC, abstractmethod class Order: def __init__(self): self.items = [] self.quantities = [] self.prices = [] self.status = &amp;#39;open&amp;#39; def add_item(self, name, quantity, price): self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self): total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def auth_sms(self, code): pass @abstractmethod def pay(self, order): pass class DebitPaymentProcessor(PaymentProcessor): def __init__(self, security_code): self.security_code = security_code self.verified = False def auth_sms(self, code): print(f&amp;#39;Verifying SMS code {code}&amp;#39;) self.</description>
    </item>
    
    <item>
      <title>Liskov Substitution Principle</title>
      <link>https://hirotoshimizu.github.io/posts/liskov-substitution-principle/</link>
      <pubDate>Fri, 18 Feb 2022 12:34:00 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/liskov-substitution-principle/</guid>
      <description>サブクラスは、スーパークラスと置換可能でなければならない。
Before from abc import ABC, abstractmethod class Order: def __init__(self) -&amp;gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = &amp;#39;open&amp;#39; def add_item(self, name: str, quantity: int, price: int) -&amp;gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -&amp;gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor(ABC): @abstractmethod def pay(self, order: Order, security_code: str) -&amp;gt; None: pass class DebitPaymentProcessor(PaymentProcessor): def pay(self, order: Order, security_code: str) -&amp;gt; None: print(&amp;#39;Processing debit payment type&amp;#39;) print(f&amp;#39;Verifying security code: {security_code}&amp;#39;) order.</description>
    </item>
    
    <item>
      <title>Open Closed Principle</title>
      <link>https://hirotoshimizu.github.io/posts/open-closed-principle/</link>
      <pubDate>Fri, 18 Feb 2022 12:02:55 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/open-closed-principle/</guid>
      <description>ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければならない。
ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべき。
Before class Order: def __init__(self) -&amp;gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = &amp;#34;open&amp;#34; def add_item(self, name: str, quantity: int, price: int) -&amp;gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -&amp;gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total class PaymentProcessor: def pay_debit(self, order: Order, security_code: str) -&amp;gt; None: print(&amp;#34;Processing debit payment type&amp;#34;) print(f&amp;#34;Verifying security code: {security_code}&amp;#34;) order.</description>
    </item>
    
    <item>
      <title>Single Responsibility Principle</title>
      <link>https://hirotoshimizu.github.io/posts/single-responsibility-principle/</link>
      <pubDate>Fri, 18 Feb 2022 10:50:17 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/single-responsibility-principle/</guid>
      <description>個々のモジュールを変更する理由がたったひとつだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会的構造に大きな影響を受けるようにする。
モジュールはたったひとつのアクターに対して責務を負うべきである。
Before class Order: def __init__(self) -&amp;gt; None: self.items = [] self.quantities = [] self.prices = [] self.status = &amp;#39;open&amp;#39; def add_item(self, name: str, quantity: int, price: int) -&amp;gt; None: self.items.append(name) self.quantities.append(quantity) self.prices.append(price) def total_price(self) -&amp;gt; int: total = 0 for i in range(len(self.prices)): total += self.quantities[i] * self.prices[i] return total def pay(self, payment_type: str, security_code: str) -&amp;gt; None: if payment_type == &amp;#39;debit&amp;#39;: print(&amp;#39;Proccessing debit payment type&amp;#39;) print(f&amp;#39;Verifying security code: {security_code}&amp;#39;) self.</description>
    </item>
    
    <item>
      <title>Solid</title>
      <link>https://hirotoshimizu.github.io/posts/solid/</link>
      <pubDate>Fri, 18 Feb 2022 10:33:01 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/solid/</guid>
      <description>よくできたソフトウェアシステムは、クリーンなコードを書くことから始まる。レンガの出来が悪ければ、その建築は優れたものにはならない。一方、たとえよくできたレンガを使っても、ぐちゃぐちゃなもの作ってしまうことがあり得る。そこで登場するのが「SOLID」原則。
SOLID原則は、関数やデータ構造をどのようにクラスに組み込むのか、そしてクラスの相互接続をどのようにするのかといったことを教えてくれる。　SOLID原則の目的は、以下のような性質を持つ中間レベルのソフトウェア構造を作ること。
 変更につよいこと 理解しやすいこと コンポーネントの基盤として、多くのソフトウェアシステムで利用できること  Single Responsibility Principle 個々のモジュールを変更する理由がたったひとつだけになるように、ソフトウェアシステムの構造がそれを使う組織の社会的構造に大きな影響を受けるようにする。
モジュールはたったひとつのアクターに対して責務を負うべきである。
Opne Closed Principle ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければならない。
ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべき。
Liskov Substitution Principle サブクラスは、スーパークラスと置換可能でなければならない。
Interface Segregation Principle 包括的なインターフェースがあるより、いくつかの特定のインターフェースに分割すべき。
Dependency Inversion Principle ソースコードの依存関係が（具象ではなく）抽象だけを参照しているシステムが最も柔軟である。</description>
    </item>
    
    <item>
      <title>Extract Function</title>
      <link>https://hirotoshimizu.github.io/posts/extract-function/</link>
      <pubDate>Fri, 18 Feb 2022 08:29:55 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/extract-function/</guid>
      <description>動機 「関数の抽出」はきわめて頻繁に行われるリファクタリング。
いつ独立した関数として取り出すかというは「2回以上使われるコードはそれ自体を関数にすべき」のように、再利用に基づいている。
しかし、最も納得できるのは意図と実装の分離です。何をしているか調べなければわからないコードの断片があるとしたら、「何」をしているかを示す名前の関数として抽出すべきです。そうすれば関数を読み返すだけで関数の目的がすぐに伝わってきます。
手順  新たな関数を作り、その意図に沿って命名する（どうやるかではなく、何をするかによって名づける。） 抽出したいコードを、元の関数から新たな関数にコピーする。 抽出したコードを調べて、元の関数ではスコープ内だったが抽出後の関数ではスコープ外になった変数を特定する。それらをパラメータとして渡す。 全ての変数を処置したらコンパイルする。 元の関数に残った抽出前のコードを、抽出された関数への呼び出しに置き換える。 テストする。 残りのコードを見て、抽出したコードと同じまたは類似したコードを探し、「関数呼び出しによるインラインコードの置き換え」を適用し、新しい関数を呼ぶ形にできないか検討する。  Before from enum import Enum class Category(Enum): A = 1 B = 2 C = 3 def calculate_tax(category: Category, income: int) -&amp;gt; int: if category == Category.A: discount = 10 elif category == Category.B: discount = 5 else: discount = 0 return income * (100 - discount) // 100 After from enum import Enum class Category(Enum): A = 1 B = 2 C = 3 def calculate_tax(category: Category, income: int) -&amp;gt; int: discount = calc_discount(category) return income * (100 - discount) // 100 def calc_discount(category: Category) -&amp;gt; int: if category == Category.</description>
    </item>
    
    <item>
      <title>Clean Code</title>
      <link>https://hirotoshimizu.github.io/posts/clean-code/</link>
      <pubDate>Thu, 17 Feb 2022 17:38:45 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/clean-code/</guid>
      <description>意味のある名前  意図が明確な名前にする 意味のある対比を行う 発音可能な名前を使用する 検索可能な名前を用いる マジックナンバーは定数に メンタルマッピングを避ける 抽象レベルに適切な名前を選ぶ 広いスコープには長い名前を エンコーディングを避ける 名前で副作用を示すべき  関数  小さいこと！ 1つのことを行う 内容をよく表す名前を使う 引数は少なく フラグ引数は使わず、メソッドを分割する 副作用をさける try/catchブロックの分離 DRY(Don&amp;rsquo;t Repeat Yourself) 死んだ関数は削除すべき  コメント 「ダメなコードをコメントで取り繕ってはいけない。書き直すのだ」
 コメントで、ダメなコードを取り繕うことはできない 自分自身をコードで説明する 意図の説明 結果に対する警告  書式化  縦方向の書式化 垂直概念分離性 垂直密度 垂直距離 水平分離性と密度  オブジェクトとデータ構造    テスト  1つのテストに1つのアサート 1つのテストでは1つの概念を扱う カバレッジツールを使用する ささいなテストを省略しない 無視することを指定されたテストは、あいまいさへの問いかけである 境界条件テストには注意払う バグの周辺は徹底的にテストを 失敗パターンは何かを語る テストカバレッジパターンは何かを語る テストは高速に実行できるべき  </description>
    </item>
    
    <item>
      <title>Code Smells</title>
      <link>https://hirotoshimizu.github.io/posts/code-smells/</link>
      <pubDate>Thu, 17 Feb 2022 15:14:16 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/code-smells/</guid>
      <description>Bloaters  長い関数(Long Method)
オブジェクトそのものの受け渡し、関数の抽出、コマンドによる関数の置き換え、問い合わせによる一時変数の置き換え、条件記述の分解、パラメータオブジェクトの導入、ポリモーフィズムによる条件記述の置き換え、ループの分離 巨大なクラス(Large Class)
クラスの抽出、サブクスによるタイプコードの置き換え、スーパークラスの抽出 データの群れ(Data Clumps)
オブジェクトそのものの受け渡し、クラスの抽出、パラメータオブジェクトの導入 長いパラメータリスト(Long Parameter List)
オブジェクトそのものの受け渡し、関数群のクラスへの集約、問い合わせによるパラメータの置き換え、パラメータオブジェクトの導入、フラグパラメータの削除 基本データ型への執着(Primitive Obsession)
オブジェクトによるプリミティブの置き換え、クラスの抽出、サブクラスによるタイプコードの置き換え、パラメータオブジェクトの導入、ポリモーフィズムによる条件記述の置き換え  Tool Abusers  Switch Statements 相続拒否(Refused Bequest)
委譲によるサブクラスの置き換え、委譲によるスーパークラスの置き換え、フィールドの押し下げ、メソッドの押し下げ クラスのインターフェース不一致(Alternative Classes w/ Different Interfaces)
関数宣言の変更、関数の移動、スーパークラスの抽出 一時的属性(Temporary Field)
関数の移動、クラスの抽出、特殊ケースの導入  Change Preventers  Divergent Change 変更の分散(Shotgun Surgery)
関数群のクラスへの集約、関数群の変換への集約、関数の移動、関数のインライン化、クラスのインライン化、フィールドの移動、フェーズの分離 Parallel Inheritance Hierarchies  Dispensables  Lazy Class 疑わしき一般化(Speculative Generality)
関数宣言の変更、関数のインライン化、クラス階層の平坦化、クラスのインライン化、デッドコードの削除 データクラス(Data Class) 重複したコード(Duplicated Code)
関数の抽出、ステートメントのスライド、メソッドの引き上げ  Couplers  特性の横恋慕(Feature Envy)
関数の移動、関数の抽出 Inappropriate Intimacy メッセージの連鎖(Message Chains)</description>
    </item>
    
  </channel>
</rss>
