<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Array on Shiglass</title>
    <link>https://hirotoshimizu.github.io/tags/array/</link>
    <description>Recent content in Array on Shiglass</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 21 Sep 2021 13:23:28 +0900</lastBuildDate><atom:link href="https://hirotoshimizu.github.io/tags/array/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Maximum Subarray</title>
      <link>https://hirotoshimizu.github.io/posts/maximum-subarray/</link>
      <pubDate>Tue, 21 Sep 2021 13:23:28 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/maximum-subarray/</guid>
      <description>https://leetcode.com/problems/maximum-subarray/
 | -2 | 1 | -3 | 4 | -1 | 2 | 1 | -5 | 4 | 最初の3つの合計(-2 + 1 -3)はマイナスになるので、 そのため subarray のスタートは 4 もしくは 4以降の数字になる。
合計が正の数になる場合は保持しておく。 変数に0 を代入して、 iterate しながら数字を追加していく。 合計がマイナスになる場合は保持する必要がないので、0 にする。
Time complexity: O(n) Mem complexity: O(1)
class Solution(object): def maxSubArray(self, nums): &amp;#34;&amp;#34;&amp;#34; :type nums: List[int] :rtype: int &amp;#34;&amp;#34;&amp;#34; max_subarray = nums[0] current_subarray = 0 for n in nums: if current_subarray &amp;lt; 0: current_subarray = 0 current_subarray += n max_subarray = max(max_subarray, current_subarray) return max_subarray </description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>https://hirotoshimizu.github.io/posts/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Tue, 21 Sep 2021 10:49:58 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/best-time-to-buy-and-sell-stock/</guid>
      <description>https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
pointer を2つ使う。 left が right より低い時点で売る可能性あり。 max_profit に最大の profit を格納。
right の pointer は右に移動し続け
left の　pointer は prices[l] が prices[r] より大きい際に、 left の pointer を right の pointer の位置に移動する。
Time complexity: O(n)
Mem complexity: O(1)
class Solution(object): def maxProfit(self, prices): &amp;#34;&amp;#34;&amp;#34; :type prices: List[int] :rtype: int &amp;#34;&amp;#34;&amp;#34; l, r = 0, 1 max_profit = 0 while r &amp;lt; len(prices): if prices[l] &amp;lt; prices[r]: profit = prices[r] - prices[l] max_profit = max(max_profit, profit) else: l = r r += 1 return max_profit </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>https://hirotoshimizu.github.io/posts/two-sum/</link>
      <pubDate>Tue, 21 Sep 2021 10:05:05 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/two-sum/</guid>
      <description>https://leetcode.com/problems/two-sum/
 | 2 | 7 | 11 | 15 | 　↑　↑ 全てのコンビネーションを確認しようと Brute Force で問題を解こうとすると ループの中でループをするのでo(n^2)となる。
 | 2 | 7 | 11 | 15 | そのため HashMapを使う必要がある。 ループして array の中を確認する際に、 HashMap に val と key を持たせる。 ループ時に target - val の値が HashMap にあれば、 合計の値を持つ index が return できる。
 | 2 | 7 | 11 | 15 |  ↑   | HashMap | | val : index | | 2 : 1 |  | HashMap | | val : index | | 2 : 1 | | 7 : 2 |← | 11 : 3 | | 15 : 4 | target は 9 なので val 7 を確認時に HashMap にすでに 2 が入っているので この時点で return できる。</description>
    </item>
    
  </channel>
</rss>
