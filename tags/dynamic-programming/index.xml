<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Dynamic Programming on Shiglass</title>
    <link>https://hirotoshimizu.github.io/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on Shiglass</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 12 Dec 2021 05:16:29 +0900</lastBuildDate><atom:link href="https://hirotoshimizu.github.io/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Longest Palindromic Substring</title>
      <link>https://hirotoshimizu.github.io/posts/longest-palindromic-substring/</link>
      <pubDate>Sun, 12 Dec 2021 05:16:29 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/longest-palindromic-substring/</guid>
      <description>https://leetcode.com/problems/longest-palindromic-substring/
class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: res = &amp;#39;&amp;#39; for i in range(len(s)): # odd case tmp = self.helper(s, i, i) if len(tmp) &amp;gt; len(res): res = tmp # even tmp = self.helper(s, i, i+1) if len(tmp) &amp;gt; len(res): res = tmp return res def helper(self, s, l, r): while l &amp;gt;= 0 and r &amp;lt; len(s) and s[l] == s[r]: l -= 1 r += 1 return s[l+1:r] </description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>https://hirotoshimizu.github.io/posts/longest-increasing-subsequence/</link>
      <pubDate>Sun, 12 Dec 2021 04:07:10 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/longest-increasing-subsequence/</guid>
      <description>https://leetcode.com/problems/longest-increasing-subsequence/
LIS はどんな場合でも最低1になるので、 1を入れた、list を作る。
reverse order でループし、 ネストしたループで最初にループしている i 以降の数と比較する。
nums[i] と nums[j] で nums[i] が小さい場合、 subsequence となるので、 LIS[i] に max(LIS[i], 1 + LIS[j]) を入れる。 j は i 以降の数字を見ているので、max()を使わないと LISの最後の 1 で置き換えて 2 となってしまうので注意。
class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: LIS = [1] * len(nums) for i in range(len(nums) - 1, -1, -1): for j in range(i + 1, len(nums)): if nums[i] &amp;lt; nums[j]: LIS[i] = max(LIS[i], 1 + LIS[j]) return max(LIS) </description>
    </item>
    
    <item>
      <title>Longest Common Subsequence</title>
      <link>https://hirotoshimizu.github.io/posts/longest-common-subsequence/</link>
      <pubDate>Sat, 11 Dec 2021 20:20:50 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/longest-common-subsequence/</guid>
      <description>https://leetcode.com/problems/longest-common-subsequence/
2d grid を作る。 row, col にそれぞれ、1行、1列追加して 0 を入れる。
grid の右下からループし、 縦横が同じ文字でマッチしたら、斜め左上に進む。 その際に1を足す。
マッチしなかったら、右横か下のどちらか大きい数字を入れる。
ループが終わりgrid[0][0] の箇所に 1番長い subsequence の数が入る。
class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&amp;gt; int: dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)] for i in range(len(text1) - 1, -1, -1): for j in range(len(text2) - 1, -1, -1): if text1[i] == text2[j]: dp[i][j] = 1 + dp[i + 1][j + 1] else: dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]) return dp[0][0] </description>
    </item>
    
    <item>
      <title>House Robber</title>
      <link>https://hirotoshimizu.github.io/posts/house-robber/</link>
      <pubDate>Mon, 18 Oct 2021 14:04:56 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/house-robber/</guid>
      <description>https://leetcode.com/problems/house-robber/
隣り合った家は訪れることが出来ないので、 変数 rob1 と rob2 を用意する。
for で全ての家を訪れ、 pointer のある位置＋rob1 と rob2 の大きい値を temp に入れる。
rob1 pointerのある位置の前の前の家 rob2 pointerのある位置のは前の家
rob2 が nums の最後の位置まで行くとループが終わるので return で rob2 を返す。
class Solution: def rob(self, num: List[int])-&amp;gt; int: rob1, rob2 = 0, 0 for n in num: temp = max(rob1 + n, rob2) rob1 = rob2 rob2 = temp return rob2 </description>
    </item>
    
    <item>
      <title>Climbing Stairs</title>
      <link>https://hirotoshimizu.github.io/posts/climbing-stairs/</link>
      <pubDate>Sun, 26 Sep 2021 12:04:50 +0900</pubDate>
      
      <guid>https://hirotoshimizu.github.io/posts/climbing-stairs/</guid>
      <description>https://leetcode.com/problems/climbing-stairs/
n = 5
 0 ／　＼ 1 2 ／＼ ／＼ 2 3 3 4 ／＼ ／＼ ／＼ ／＼ 3 4 4 5 4 5 5 6  ／＼ ／＼ ／＼　／＼ 4 5 5 6 5 6　5 6 ／＼ 5 6
n が 5 steps の場合、 8通りの選択が出来る。
DFS でも出来るかが 2^n となる。
そのため Dynamic Programming を使う。
同じ計算をする値は memoize する
 | 8 | 5 | 3 | 2 | 1 | 1 | n に辿り着くまでの数 0 1 2 3 4 5(step) one two</description>
    </item>
    
  </channel>
</rss>
